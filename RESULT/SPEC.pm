package DDB::RESULT::SPEC;
use strict;
use Carp;
use DDB::UTIL;
sub update {
	my($self,%param)=@_;
	my $RESULT = $param{result} || confess "Needs result\n";
	my $log = '';
	$log .= sprintf "Updating table '%s' (in '%s') of type '%s'\n==> Log <==\n", $RESULT->get_table_name(),$RESULT->get_resultdb(),ref($RESULT) if $param{debug} > 0;
	# check result type:
	if (ref($RESULT) eq 'DDB::RESULT::USER') {
		confess "DDB::RESULT::USER tables cannot be updated using this script. USER tables are maintained by the user and is not generated by code\n";
	} elsif (ref($RESULT) eq 'DDB::RESULT::SQL') {
		confess "Check bddbResult_127 sub before updating this\n" if $RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 127;
		printf "Do you want to update %d (drop, and then recreate table) [NO/yes]? ",$RESULT->get_id();
		my $res;
		if ($param{force}) {
			$res = 'y';
		} else {
			$res = <STDIN>;
			chomp $res;
		}
		if ($res =~ /^y/i) {
			$RESULT->generate_table( print_statement => 1 );
		} else {
			printf "NOT updating ($res)\n";
		}
	} elsif (ref($RESULT) eq 'DDB::RESULT::AUTO') {
		my $function = sprintf "%s_%d", $RESULT->get_resultdb(),$RESULT->get_id();
		my $fun = \&$function;
		$log .= $fun->( %param ) || '';
	} else {
		confess sprintf "Unknown reuslt type: %s\n", ref($RESULT);
	}
	return $log || '';
}
sub bddbResult_117 {
	my(%param)=@_;
	my $RESULT = $param{result};
	# I guess this is a raw import from the scopFold files
	if (1==1) {
		my $aryref = $RESULT->querycol("SELECT DISTINCT prediction_file FROM #TABLE#");
		my $sthUpdate = $RESULT->queryprepare("UPDATE #TABLE117# SET zscore_rank = ? WHERE id = ?");
		my $sthGet = $RESULT->queryprepare("SELECT id,prediction_file,zscore FROM #TABLE# WHERE prediction_file = ? ORDER BY zscore DESC");
		printf "Found %d prediction_structure_keys\n", $#$aryref+1;
		for my $index (@$aryref) {
			$sthGet->execute( $index );
			printf "%d ids for %s\n", $sthGet->rows(),$index;
			my $count = 0;
			while (my ($id,$pre,$zscore) = $sthGet->fetchrow_array()) {
				$count++;
				#confess "Bad\n" unless $pre eq $index;
				printf "$id $pre $index $zscore $count\n";
				#$sthUpdate->execute( $count, $id );
			}
			last;
		}
	}
}
sub bddbResult_122 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 122
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::PROGRAM::PIMW;
	# create table test.humseq select distinct sequence_key from {nrtax_table} inner join {nrac_table} on {nrac_table}.gi = {nrtax_table}.gi where taxonomy_id = 9606;
	my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM test.humseq");
	for my $id (@$aryref) {
		my $pos = 1;
		my $buf = 1;
		my $buff = 0;
		my $fseq = $ddb_global{dbh}->selectrow_array("SELECT sequence from {nrseq_table} WHERE id = $id");
		#printf "FULL (%d aa):\n%s\n",length($fseq), $fseq;
		for (my $i = 0; $i < length($fseq); $i++) {
			eval {
				my $current = substr($fseq,$i,1);
				if ($current eq 'K' || $current eq 'R' || $i == length($fseq)-1) {
					my $stop = $i+1;
					my $start = $buff;
					my $sseq = substr($fseq,$start,$stop-$start);
					#printf "%s %s %s\n", $start,$stop,$sseq;
					$buff = $stop;
					my $pi,my $mw;
					($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $sseq ) if $sseq;
					my %data;
					my $has = ($sseq =~ /C/) ? 'yes':'no';
					$data{sequence_key} = $id;
					$data{start} = $start+1;
					$data{stop} = $stop;
					$data{mw} = $mw;
					$data{pI} = $pi;
					$data{hasCystine} = $has;
					$data{sequence} = $sseq;
					$RESULT->insertignore( %data ) if $sseq;
				};
				printf "FAILED %s\n", (split /\n/, $@)[0] if $@;
			}
		}
		while (1==0) {
			my $posk = $ddb_global{dbh}->selectrow_array("SELECT LOCATE('K',sequence,$pos) from {nrseq_table} WHERE id = $id");
			my $posr = $ddb_global{dbh}->selectrow_array("SELECT LOCATE('R',sequence,$pos) from {nrseq_table} WHERE id = $id");
			$pos = ($posk > $posr) ? $posk : $posr;
			my $last = 1 unless $pos;
			$pos += 1; # length of match
			my $sseq;
			unless ($last) {
				$sseq = $ddb_global{dbh}->selectrow_array(sprintf "SELECT SUBSTRING(sequence,%d,%d) from {nrseq_table} WHERE id = %d",$buf,$pos-$buf,$id);
			} else {
				$sseq = $ddb_global{dbh}->selectrow_array("SELECT SUBSTRING(sequence,$buf) from {nrseq_table} WHERE id = $id");
			}
			my $to = $pos-1;
			$to = length($fseq) if $pos == 1;
			my $pi; my $mw;
			($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $sseq ) if $sseq;
			printf "%d %d %d (%d aa) pI: %s MW: %s\n%s\n", $id,$buf,$to,length($sseq),$pi,$mw,$sseq;
			my %data;
			my $has = ($sseq =~ /C/) ? 'yes':'no';
			$data{sequence_key} = $id;
			$data{start} = $buf;
			$data{stop} = $to;
			$data{mw} = $mw;
			$data{pI} = $pi;
			$data{hasCystine} = $has;
			$data{sequence} = $sseq;
			$RESULT->insertignore( %data ) if $sseq;
			$buf = $pos;
			last if $last;
		}
	}
}
sub bddbResult_125 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 125
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==1) { # pdb to scop_sccs
		require DDB::DATABASE::SCOP::PX;
		my $aryref = $RESULT->querycol( "SELECT DISTINCT id FROM #TABLE# WHERE pdb != '' AND scop_sccs = ''" );
		printf "%d guys\n", $#$aryref+1;
		for my $id (@$aryref) {
			my ($pdb,$chain) = $RESULT->queryrow( "SELECT pdb,chain FROM #TABLE# WHERE id = $id" );
			my $px_aryref = DDB::DATABASE::SCOP::PX->get_ids( pdbid => $pdb, part_text_like => $chain );
			if ($#$px_aryref < 0) {
				printf "Could not find scop classification for: pdb %s chain %s\n", $pdb,$chain;
				next;
			} else {
				my %hash;
				for my $px_id (@$px_aryref) {
					my $PX = DDB::DATABASE::SCOP::PX->new( id => $px_id );
					$PX->load();
					$hash{ $PX->get_sccs() } = $PX->get_part_text();
				}
				my @sccs = keys %hash;
				printf "%d matches, %d sccs (%s)\n", $#$px_aryref+1,$#sccs+1,join ", ", map{ sprintf "%s => %s", $_, $hash{$_} }@sccs;
				next unless $#sccs == 0;
				printf "Updating %d %s %s\n", $id, $pdb,$chain;
				$RESULT->querydo( "UPDATE #TABLE# SET scop_sccs = '$sccs[0]' WHERE id = $id" );
			}
			last;
		}
	}
	if (1==0) { # by databases
		my $aryref = $RESULT->querycol( "SELECT DISTINCT native_structure_key FROM #TABLE# WHERE pdb = ''" );
		printf "%d guys\n", $#$aryref+1;
		require DDB::STRUCTURE;
		require DDB::SEQUENCE::AC;
		require DDB::DATABASE::PDB::SEQRES;
		for my $stkey (@$aryref) {
			my $STRUCT = DDB::STRUCTURE->get_object( id => $stkey );
			printf "%s\n", ref($STRUCT);
			if (1==1) { # using pdb or lbpdb
				my $aryref = DDB::SEQUENCE::AC->get_ids( dbarray => ['pdb','lbpdb'], sequence_key => $STRUCT->get_sequence_key() );
				unless ($#$aryref < 0) {
					confess "Implement..\n";
				}
			}
			if (1==1) {
				my $SEQ = DDB::SEQUENCE->new( id => $STRUCT->get_sequence_key() );
				$SEQ->load();
				my $aryref = DDB::DATABASE::PDB::SEQRES->get_ids( sequence => $SEQ->get_sequence());
				unless ($#$aryref < 0) {
					confess "Implement...\n";
				}
			}
			last;
		}
	}
	if (1==0) { # by numbers
		my $SR = DDB::RESULT->get_object( id => 123 );
		my $aryref = $SR->querycol( "SELECT DISTINCT native_structure_key FROM #TABLE#" );
		printf "%d guys\n", $#$aryref+1;
		my $f;my $g;
		for my $stkey (@$aryref) {
			my $total = $SR->queryrow("SELECT COUNT(*) FROM #TABLE# WHERE native_structure_key = $stkey");
			my ($sccs,$max) = $SR->queryrow( "SELECT domain_sccs,zscore FROM #TABLE# WHERE native_structure_key = $stkey ORDER BY zscore DESC" );
			my $count = $SR->queryrow("SELECT COUNT(*) FROM #TABLE# WHERE native_structure_key = $stkey AND domain_sccs = '$sccs'");
			my ($sccs2,$max2) = $SR->queryrow( "SELECT domain_sccs,zscore FROM #TABLE# WHERE native_structure_key = $stkey AND domain_sccs != '$sccs' ORDER BY zscore DESC" );
			my $count2 = $SR->queryrow("SELECT COUNT(*) FROM #TABLE# WHERE native_structure_key = $stkey AND domain_sccs = '$sccs2'");
			my $corr = '';
			my $ts = join ".", (split /\./, $sccs)[0..1];
			my $ts2 = join ".", (split /\./, $sccs2)[0..1];
			#printf "%s %s\n", $ts,$ts2;
			if ($max > 15) {
				$corr = 'z15';
			} elsif (($max-$max2) > 3) {
				$corr = 'd3';
			} elsif ($max > 8 && $max-$max2 > 1.5 ) {
				$corr = 'z8d1.5';
			} elsif ($max > 6 && $max < 8 && $max-$max2 > .5 ) {
				$corr = 'z6d.5b';
			} elsif ($max > 8 && $count > $count2) {
				$corr = 'z8c1';
			} elsif ($ts eq $ts2) {
				$corr = 'fold';
			}
			my $form = "%10s: %3d %3d 1: %10s %10s %4d 2: %10s %10s %4d\n";
			my %data;
			if ($corr) {
				$data{correct} = 'yes';
				$data{comment} = $corr;
				$data{native_structure_key} = $stkey;
				$data{sccs} = $sccs;
				#printf $form,$corr, $stkey,$total,$sccs,$max,$count,$sccs2,$max2,$count2;
				$g++;
			} else {
				$data{correct} = 'no';
				$data{comment} = sprintf $form,'Figure', $stkey,$total,$sccs,$max,$count,$sccs2,$max2,$count2;
				$data{native_structure_key} = $stkey;
				$data{sccs} = '';
				$f++;
			}
			$RESULT->insertignore( %data );
			#last if $f > 10;
		}
		printf "Good: $g, Figure $f\n";
	}
}
sub bddbResult_127 {
	# this guy have an initial statemnt that was In resultSQL.statemetn before.
	#create table #TABLE127# select mcmData.*,protein.sequence_key as prediction_sequence_key,' as prediction_sccs, 0 as correct_fold from explorerGroupMember INNER JOIN explorerProtein ON explorerProtein_key = explorerProtein.id INNER JOIN protein ON protein_key = protein.id INNER JOIN filesystemOutfile ON protein.sequence_key = filesystemOutfile.sequence_key INNER JOIN mcmData ON filesystemOutfile.id = outfile_key WHERE group_key IN (7084,7088,7089);
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==0) {
		### update prediction_sccs ###
		#update confFuncLBnativesCorrect inner join bddb.structure on native_structure_key = structure.id inner join structureMcmDataLb ON sequence_key = prediction_sequence_key set prediction_sccs = scop_sccs where scop_sccs != '' and prediction_sccs = '';
		### update correct fold ###
		### zscore-rank ###
		#alter table structureMcmDataLb change prediction_sccs prediction_sccs varchar(15) not null;
		#alter table structureMcmDataLb add index(prediction_sccs);
		#alter table structureMcmDataLb add primary key (id);
		#alter table structureMcmDataLb change id id int not null auto_increment;
		#alter table structureMcmDataLb add column testprob double not null;
		#alter table structureMcmDataLb add index(class);
		#alter table structureMcmDataLb add index(testprob);
		#alter table structureMcmDataLb add index(prediction_file);
		#alter table structureMcmDataLb add index(zscore_rank);
		#alter table structureMcmDataLb add index(zscore);
		#alter table structureMcmDataLb add column zscore_rank int not null after zscore;
		#alter table structureMcmDataLb add index(experiment_sccs);
		#alter table structureMcmDataLb add column inMDB int not null;
		### inMDB ###
		#update structureMcmDataLb inner join mcmMammothData ON substring_index(prediction_sccs,".",2) = substring_index(sccs,".",2) set inMDB = 1;
		# testprob
		# UPDATE structureMcmDataLb SET testprob = 1/(1+1/exp( (prediction_contact_order * 0.143566) + (prediction_sequence_length * 0.024803) + (convergence * -0.403005) + (abs(log(prediction_sequence_length/experiment_sequence_length)) * -4.393747) + (zscore * 0.288840) + (prediction_percent_alpha * -3.842328) + -0.990634 )) WHERE class = 1;
		# UPDATE structureMcmDataLb SET testprob = 1/(1+1/exp( (prediction_contact_order * 0.07152) + (convergence * -0.30801) + (abs(log(prediction_sequence_length/experiment_sequence_length)) * -5.88389) + (zscore * 0.34356) )) WHERE class = 2;
		# UPDATE structureMcmDataLb SET testprob = 1/(1+1/exp( (prediction_contact_order * 0.068526) + (convergence * -0.066641) + (abs(log(prediction_sequence_length/experiment_sequence_length)) * -6.411107) + (zscore * 0.615780) + (prediction_percent_alpha * -2.754779) + -2.785914 )) WHERE class = 3;
	}
	if (1==1) {
		require DDB::DATABASE::SCOP;
		my $aryref = $RESULT->querycol("SELECT id FROM #TABLE# WHERE prediction_sccs != '' AND experiment_sccs != ''");
		my $sthGet = $RESULT->queryprepare("SELECT prediction_sccs,experiment_sccs FROM #TABLE# WHERE id = ?");
		my $sthUpdate = $RESULT->queryprepare("UPDATE #TABLE# SET correct_fold = ? WHERE id = ?");
		printf "Found %d ids\n", $#$aryref+1;
		for my $id (@$aryref) {
			$sthGet->execute( $id );
			my ($pred,$exp) = $sthGet->fetchrow_array();
			my $corr = DDB::DATABASE::SCOP->same_fold( $pred,$exp );
			#printf "%s %s %s %d\n", $pred,$exp,$corr,$id;
			$sthUpdate->execute( $corr, $id );
			#last if $corr;
		}
	}
	if (1==0) {
		my $aryref = $RESULT->querycol("SELECT DISTINCT prediction_file FROM #TABLE#");
		my $sthUpdate = $RESULT->queryprepare("UPDATE #TABLE# SET zscore_rank = ? WHERE id = ?");
		my $sthGet = $RESULT->queryprepare("SELECT id,prediction_file,zscore FROM #TABLE# WHERE prediction_file = ? ORDER BY zscore DESC");
		printf "Found %d prediction_structure_keys\n", $#$aryref+1;
		for my $index (@$aryref) {
			$sthGet->execute( $index );
			printf "%d ids for %s\n", $sthGet->rows(),$index;
			my $count = 0;
			while (my ($id,$pre,$zscore) = $sthGet->fetchrow_array()) {
				$count++;
				#confess "Bad\n" unless $pre eq $index;
				#printf "$id $pre $index $zscore $count\n";
				$sthUpdate->execute( $count, $id );
			}
			#last;
		}
	}
}
sub bddbResult_134 {
	confess "Obsolete...\n";
}
sub bddbResult_135 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 135
	my(%param)=@_;
	my $RESULT = $param{result};
	# In oke:~/check, there is a listfile
	confess "No file\n" unless $param{file};
	confess "Cant find file\n" unless -f $param{file};
	open IN, "<$param{file}";
	my @ids = <IN>;
	close IN;
	for my $id (@ids) {
		my $file = sprintf "folders/t%02d/%05d/%s", substr($id,0,length($id)-4),$id,'t000_.pdb_6.msa.gz';
		printf "%d %s %s\n", $id, substr($id,-5,1) , $file;
		confess "Cannot find file...\n" unless -f $file;
		my @lines = `zcat $file`;
		chomp @lines;
		shift @lines;
		#shift @lines;
		for my $line (@lines) {
			my ($code,$len,$ident,$score,$evalue,$ranges,$seq,$rest) = split /\s+/, $line;
			confess "Has rest: $rest\nFrom: $line\n" if $rest;
			$score = -1 if $score =~ /^\*+$/;
			$evalue = -1 if $evalue =~ /^\*+$/;
			my ($qs,$qe,$ps,$pe) = $ranges =~ /^(\d+)-(\d+):(\d+)-(\d+)$/;
			my $sth = $ddb_global{dbh}->prepare("INSERT bddbResult.yeastReblast (sequence_key,code,alilen,ident,score,evalue,qstart,qend,pstart,pend,sequence) VALUES (?,?,?,?,?,?,?,?,?,?,?)");
			$sth->execute( $id, $code, $len, $ident, $score, $evalue, $qs, $qe, $ps, $pe, $seq);
		}
	}
}
sub bddbResult_136 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my %data;
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# ( `id` int(11) NOT NULL auto_increment, `measurement` varchar(255) NOT NULL default '', `value` double NOT NULL default '0', str_value varchar(255) NOT NULL default '', `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `measurement` (`measurement`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 ");
	}
	if (1==0) {
		# n with SGD
		# Make sure this still works after SGD200409 is moved from evidence_code to source In ddb.go
		$data{measurement} = "Number of Sequences with a SGD200409 mol.func annotation";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT sequence_key) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409'");
		$RESULT->insertignore( %data );
		# avg SGDgoann
		$data{measurement} = "Average Number of goAssignments with a SGD200409 mol.func annotation";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT AVG(ngo) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409'");
		$RESULT->insertignore( %data );
		# avg ginzugoann
		$data{measurement} = "Average Number of Abi Go Predoictions with a SGD200409 mol.func annotation";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT AVG(nginzu) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409'");
		$RESULT->insertignore( %data );
		# total ginzugoann
		$data{measurement} = "Total Number of Abi Go Predoictions with a SGD200409 mol.func annotation";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT SUM(nginzu) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409'");
		$RESULT->insertignore( %data );
		# total correct ginzugoann
		$data{measurement} = "Total Number of Abi Go Predoictions with a SGD200409 mol.func annotation on correct path";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT SUM(ident+spec+less) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409'");
		$RESULT->insertignore( %data );
		# identical
		$data{measurement} = "Number of Sequences with a SGD200409 mol.func annotation with an identical abinitio prediction";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT sequence_key) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409' and ident > 0");
		$RESULT->insertignore( %data );
		# correct path
		$data{measurement} = "Number of Sequences with a SGD200409 mol.func annotation with an abinitio prediction on path";
		$data{value} = $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT sequence_key) FROM bddbResult.yeastDomainFsum WHERE measurement = 'SGD200409' and ident+spec+less > 0");
		$RESULT->insertignore( %data );
	}
	if (1==1) {
		my $exp = '1';
		$RESULT->insert( measurement => 'Experiment', str_value => $exp );
		$RESULT->insert( measurement => "N sequences", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = sequence_key WHERE experiment_key IN ($exp) AND domain_source = 'ginzu'") } );
		$RESULT->insert( measurement => 'N domains', value => do{ $ddb_global{dbh}->selectrow_array("SELECT SUM(n_domains) FROM bddbResult.yeastPaperT1") } );
		$RESULT->insert( measurement => 'N domain without structure', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(*) FROM bddbResult.yeastPaperS1 WHERE detect_method NOT IN ('psiblast','fold_recognition')") } );
		$RESULT->insert( measurement => 'N domain with structure', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(*) FROM bddbResult.yeastPaperS1 WHERE detect_method IN ('psiblast','fold_recognition')") } );
		$RESULT->insert( measurement => 'N FR domains', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(*) FROM bddbResult.yeastPaperS1 WHERE detect_method IN ('fold_recognition')") } );
		$RESULT->insert( measurement => 'N foldables', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(distinct sequence_key) FROM bddbResult.highMcmPredictionYeast WHERE dataset = 'yeast' AND method = 'structure'") } );
		$RESULT->insert( measurement => 'N folded', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(distinct sequence_key) FROM bddbResult.highMcmPredictionYeast WHERE dataset = 'yeast' AND method = 'structure' AND n_tm = 0") } );
		$RESULT->insert( measurement => 'N folded with TM', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(distinct sequence_key) FROM bddbResult.highMcmPredictionYeast WHERE dataset = 'yeast' AND method = 'structure' AND n_tm > 0") } );
		$RESULT->insert( measurement => 'N confident MCM', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(distinct domain_sequence_key) FROM bddbResult.yeastPaperS2") } );
		$RESULT->insert( measurement => 'N confident GI', value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(distinct domain_sequence_key) FROM bddbResult.yeastPaperS3") } );
		$RESULT->insert( measurement => '% domains by FR', value => do{ $ddb_global{dbh}->selectrow_array("select round(n_domains/value*100,1) from bddbResult.yeastPaperT1,bddbResult.yeastDomainPubVal where method = 'fold_recognition' and measurement = 'N domains';") } );
		$RESULT->insert( measurement => '% domains by PSIBLAST', value => do{ $ddb_global{dbh}->selectrow_array("select round(n_domains/value*100,1) from bddbResult.yeastPaperT1,bddbResult.yeastDomainPubVal where method = 'psiblast' and measurement = 'N domains';") } );
		$RESULT->insert( measurement => "# predictions for yeastintern with sign. mcm and gi", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT a.sequence_key) FROM bddbResult.highMcmPredictionYeast a INNER JOIN bddbResult.highMcmPredictionYeast b ON a.sequence_key = b.sequence_key WHERE a.dataset = 'yeastInternal' AND a.method = 'structure' AND a.probability >= 0.8 AND a.n_tm = 0 AND a.good_domain_parse = 1 AND b.dataset = 'yeastInternal' AND b.method = 'integration' AND b.n_tm = 0 and b.good_domain_parse = 1 AND b.probability >= 0.8") } );
		$RESULT->insert( measurement => "# predictions for HPF with sign. mcm and gi", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT a.sequence_key) FROM bddbResult.highMcmPredictionYeast a INNER JOIN bddbResult.highMcmPredictionYeast b ON a.sequence_key = b.sequence_key WHERE a.dataset = 'HPF' AND a.method = 'structure' AND a.probability >= 0.8 AND a.n_tm = 0 AND a.good_domain_parse = 1 AND b.dataset = 'HPF' AND b.method = 'integration' AND b.n_tm = 0 and b.good_domain_parse = 1 AND b.probability >= 0.8") } );
		$RESULT->insert( measurement => "# good HPF", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT a.sequence_key) FROM bddbResult.highMcmPredictionYeast a WHERE a.dataset = 'HPF' AND a.method = 'structure' AND n_tm = 0 AND good_domain_parse = 1") } );
	}
	return '';
}
sub bddbResult_137 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 137
	my(%param)=@_;
	my $RESULT = $param{result};
	my $DOM = DDB::RESULT->get_object( id => 138 );
	my $REG = DDB::RESULT->get_object( id => 139 );
	require DDB::FILE;
	my $FILE = DDB::FILE->new( id => 6 ); # file from dylan
	$FILE->load();
	my $content = $FILE->get_file_content();
	my @lines = split /\n/, $content;
	shift @lines;
	printf "%d lines to import\n", $#lines;
	for my $line (@lines) {
		#printf "%s\n", $line;
		my %data;my $code;my $rest;
		($code,$data{cath},$data{scop},$data{taylor},$data{taylorcon},$data{ginzulite},$data{ginzulitem},$data{denovol},$data{denovom},$data{msa2domainl},$data{msa2domainm},$rest) = split /\t/, $line;
		confess "$line has rest...\n" if $rest;
		my %code;
		$code{code} = $code;
		$RESULT->insertignore( %code );
		my $codekey = $RESULT->get_id_from_data( %code );
		confess "No codekey\n" unless $codekey;
		for my $key (keys %data) {
			my $domainnr = 0;
			for my $domain (split /\//, $data{$key}) {
				$domainnr++;
				my %domain;
				$domain{method} = $key;
				$domain{bound_key} = $codekey;
				$domain{domain_nr} = $domainnr;
				$DOM->insertignore(%domain);
				my $domid = $DOM->get_id_from_data( %domain );
				confess "No domid\n" unless $domid;
				for my $region (split /\,/,$domain) {
					my($start,$stop) = split /\-/, $region;
					my %region;
					confess "Cannot parse $region\n" unless $start && $stop;
					$region{dom_key} = $domid;
					$region{start} = $start;
					$region{stop} = $stop;
					$REG->insertignore( %region );
					my $regid = $REG->get_id_from_data( %region );
					#printf "%s: %s; %d\n", $domain,$region,$regid;
				}
			}
		}
	}
}
sub bddbResult_140 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 140
	my(%param)=@_;
	my $RESULT = $param{result};
	my $aryref1 = $ddb_global{dbh}->selectcol_arrayref("SELECT DISTINCT sequence_key FROM bddbResult.yeastDomainFsum WHERE measurement = 'sgd200409'");
	my $aryref2 = $ddb_global{dbh}->selectcol_arrayref("SELECT DISTINCT sequence_key FROM bddbResult.yeastDomainFsum WHERE measurement = 'sgd200409'");
	&_shuffle( $aryref2 );
	for (my $i=0;$i<@$aryref1;$i++) {
		my %data;
		$data{sequence_key} = $aryref1->[$i];
		$data{random_sequence_key} = $aryref2->[$i];
		$RESULT->insertignore( %data );
		#printf "%d %d\n", $aryref1->[$i],$aryref2->[$i];
	}
}
sub bddbResult_141 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 141
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::SEQUENCE;
	require DDB::SEQUENCE::AC;
	require DDB::STRUCTURE;
	my $CODE = DDB::RESULT->get_object( id => 137 );
	my $aryref = $CODE->get_data_column( column => 'code' );
	warn "Not updating...\n";
	if (1==0) { # import bddb seq and update code-db
		for my $code (@$aryref) {
			my %code = ( code => $code );
			my $codeid = $CODE->get_id_from_data( %code );
			my %bound = ( bound_key => $codeid );
			my $id = $RESULT->get_id_from_data( %bound );
			my $fasta = $RESULT->get_data_cell( column => 'fasta', where => \%bound );
			my $pdbgz = $RESULT->get_data_cell( column => 'pdbgz', where => \%bound );
			my $resmap = $RESULT->get_data_cell( column => 'resmap', where => \%bound );
			my $dir = get_tmpdir();
			my $tmpfilegz = "$dir/pdb.gz";
			my $tmpfile = "$dir/pdb";
			unlink $tmpfilegz if -f $tmpfilegz;
			confess "Still there...\n" if -f $tmpfilegz;
			open OUT, ">$tmpfilegz";
			print OUT $pdbgz;
			close OUT;
			print `gunzip -c $tmpfilegz > $tmpfile`;
			confess "No file produced..\n" unless -f $tmpfile;
			unlink $tmpfilegz;
			my $pdb = `cat $tmpfile`;
			#printf "%d %d\nHEAD: %s\n",length($pdbgz),length($pdb), substr($pdb,0,1000);
			my $STRUCT = DDB::STRUCTURE->new();
			DDB::STRUCTURE->parse_file( structure => $STRUCT, file => $tmpfile );
			$STRUCT->set_resmap( $resmap );
			unlink $tmpfile;
			$resmap = $RESULT->get_data_cell( column => 'resmap', where => \%bound );
			my @lines = split /\n/, $fasta;
			my $head = shift @lines;
			confess "Something wrong...\n" unless $head =~ /$code/;
			my $seq = join "", @lines;
			$seq =~ s/\W//;
			my $finalseq = 0;
			if (my $seqid = DDB::SEQUENCE->exists( sequence => $seq )) {
				$finalseq = $seqid;
				printf "Does exist $seqid\n";
			} else {
				my $SEQ = DDB::SEQUENCE->new();
				$SEQ->set_sequence( $seq );
				$SEQ->set_comment( "pdb sequence from $code: dylan benchmark processed" );
				$SEQ->add();
				my $AC = DDB::SEQUENCE::AC->new();
				$AC->set_sequence_key( $SEQ->get_id() );
				$AC->set_comment( "pdb sequecne from $code: dylan benchmark processed" );
				$AC->set_db( 'procpdb' );
				$AC->set_ac( $code );
				$AC->set_ac2( $code );
				$AC->add_wo_gi();
				printf "Does NOT exist: added %d: ac: %d\n",$SEQ->get_id(),$AC->get_id();
				$finalseq = $SEQ->get_id();
			}
			confess "No finalseq\n" unless $finalseq;
			$STRUCT->set_sequence_key( $finalseq );
			$STRUCT->set_structure_type( 'compl_renum' );
			$STRUCT->addignore_setid();
			$CODE->update( values => { sequence_key => $finalseq }, where => { id => $codeid } );
			printf "%s %d %d %d\n", $code,$codeid,$id,$finalseq;
		}
	}
	if (1==0) { # import
		for my $code (@$aryref) {
			my %code;
			my %data;
			$code{code} = $code;
			my $codeid = $CODE->get_id_from_data( %code );
			$data{bound_key} = $codeid;
			my $dir = sprintf "%s/dylan/%s/%s",get_tmpdir(), substr($code,1,2),$code;
			confess "Cannot find directory\n" unless -d $dir;
			my @fastafile = glob("$dir/*.fasta");
			confess "Wrong\n" unless $#fastafile == 0;
			my @nativepdb = glob("$dir/*.pdb.gz");
			confess "Wrong\n" unless $#nativepdb == 0;
			my @resmap = glob("$dir/*.resmap");
			confess "Wrong\n" unless $#resmap == 0;
			printf "%s In %s %s %s %s\n", $code,$dir,$fastafile[0],$nativepdb[0],$resmap[0];
			local $/;
			undef $/;
			open IN, "<$fastafile[0]";
			$data{fasta} = <IN>;
			close IN;
			open IN, "<$nativepdb[0]";
			$data{pdbgz} = <IN>;
			close IN;
			open IN, "<$resmap[0]";
			$data{resmap} = <IN>;
			close IN;
			$RESULT->insertignore( %data );
		}
	}
}
sub bddbResult_142 {
	#$RESULT->get_resultdb eq 'bddbResult' && $RESULT->get_id() == 142
	my(%param)=@_;
	my $RESULT = $param{result};
	my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT DISTINCT b.id FROM test.tmptab3 INNER JOIN bddbResult.yeastDomainBoundary b ON seqkey = sequence_key");
	printf "%d b.ids\n", $#$aryref+1;
	my $sth = $ddb_global{dbh}->prepare("SELECT * FROM bddbResult.yeastDomainBoundary b INNER JOIN bddbResult.yeastDomainBoundaryDomain d ON bound_key = b.id INNER JOIN bddbResult.yeastDomainBoundaryRegion ON dom_key = d.id WHERE b.id = ? AND method = ? ORDER BY domain_nr");
	for my $id (@$aryref) {
		printf " ==> $id <== \n";
		my %data;
		$data{bound_key} = $id;
		$sth->execute($id,'cath');
		$data{cath_ndom} = $sth->rows();
		my @cath_bound = &GetBoundary( $sth );
		$data{cath_bound} = join ",", @cath_bound;
		$sth->execute($id,'denovol');
		$data{deno_ndom} = $sth->rows();
		my @deno_bound = &GetBoundary( $sth );
		$data{deno_bound} = join ",", @deno_bound;
		my @deno_off;
		for my $cath (@cath_bound) {
			my $min = -1;
			for my $deno (@deno_bound) {
				my $buf = abs($cath-$deno);
				$min = $buf if $min == -1;
				$min = $buf if $buf < $min;
			}
			push @deno_off, $min;
		}
		$data{deno_off} = join ",", @deno_off;
		$sth->execute($id,'msa2domainl');
		$data{msa_ndom} = $sth->rows();
		my @msa_bound = &GetBoundary( $sth );
		my @msa_off;
		for my $cath (@cath_bound) {
			my $min = -1;
			for my $msa (@msa_bound) {
				my $buf = abs($cath-$msa);
				$min = $buf if $min == -1;
				$min = $buf if $buf < $min;
			}
			push @msa_off, $min;
		}
		$data{msa_off} = join ",", @msa_off;
		$data{msa_bound} = join ",", @msa_bound;
		for my $key (sort{ $a cmp $b }keys %data) {
			#printf "%s => %s\n", $key,$data{$key};
		}
		$RESULT->insertignore( %data );
	}
}
sub bddbResult_151 {
	confess "Obsolete...\n";
}
sub bddbResult_153 {
	my(%param)=@_;
	my $RESULT = $param{result} || confess "No result\n";
	confess "No param-file\n" unless $param{file};
	confess "Cannot find param-file $param{file}\n" unless -f $param{file};
	my $log;
	local $/;
	$/ = "\n>";
	open IN, "<$param{file}";
	my @fasta = <IN>;
	close IN;
	$log .= sprintf "%d fastas found In file %s\n", $#fasta+1,$param{file};
	$fasta[0] =~ s/^>// || confess "Cannot remove expected symbol\n";
	my %data;
	for my $fasta (@fasta) {
		$fasta =~ s/\n>//;
		my @lines = split /\n/, $fasta;
		my $head = shift @lines;
		$data{sequence} = join "", @lines;
		$data{sequence} =~ s/\W//;
		$data{sequence} = uc($data{sequence});
		($data{code},$data{sccs},$data{description}) = $head =~ /^([\w\.]+)\s(\w\.\d+\.\d+\.\d+)\s(.+)$/;
		confess "No code or sccs or descriptoin or sequence ($head)\n" unless $data{code} && $data{sccs} && $data{description} && $data{sequence};
		$RESULT->insertignore( %data );
		#$log .= $fasta."\n";
		#$log .= sprintf "stuff: '%s' '%s' '%s'\nhead: %s\nseq:\n%s\n",$code,$sccs,$description, $head,$data{sequence};
	}
	$log .= sprintf "%d sequences In experiment 6\n", $RESULT->querydo("UPDATE #TABLE# a INNER JOIN bddb.sequence s ON a.sequence = s.sequence INNER JOIN bddb.protein ON s.id = sequence_key SET in_exp_6 = 1 WHERE experiment_key = 6");
	return $log;
}
sub bddbResult_155 {
	&bddbResult_153( @_ );
}
sub bddbResult_160 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my @statement;
	push @statement, "DROP TABLE #TABLE#";
	push @statement, "CREATE TABLE #TABLE# SELECT go.acc,COUNT(DISTINCT protein.sequence_key) AS count FROM bddb.protein INNER JOIN bddb.go ON protein.sequence_key = go.sequence_key INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON go.acc = term.acc WHERE experiment_key = 1 AND term_type = 'biological_process' GROUP BY go.acc";
	push @statement, "ALTER TABLE #TABLE# ADD COLUMN probability DOUBLE NOT NULL";
	push @statement, "ALTER TABLE #TABLE# ADD COLUMN goterm_id INT NOT NULL AFTER acc";
	push @statement, "UPDATE #TABLE# a INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON a.acc = term.acc SET goterm_id = term.id";
	push @statement, "ALTER TABLE #TABLE# ADD UNIQUE(acc)";
	push @statement, "ALTER TABLE #TABLE# ADD UNIQUE(goterm_id)";
	push @statement, "ALTER TABLE #TABLE# ADD INDEX(count)";
	push @statement, "ALTER TABLE #TABLE# ADD INDEX(probability)";
	for my $stat (@statement) {
		printf "$stat\n";
		$RESULT->querydo($stat);
	}
	my $count = $RESULT->queryrow("SELECT SUM(count) FROM #TABLE#");
	$RESULT->querydo("UPDATE #TABLE# SET probability = count/$count");
}
sub bddbResult_162 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my @statement;
	push @statement, "DROP TABLE #TABLE#";
	push @statement, "CREATE TABLE #TABLE# SELECT SUBSTRING_INDEX(sccs,'.',3) AS sccs ,goTermId,term_type,count(*) AS count,0.0 AS probability FROM bddbResult.goMapping_pdb2goNoScopFold pdb INNER JOIN scop.scop_cla ON pdb_id = pdb INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON goTermId = term.id GROUP BY SUBSTRING_INDEX(sccs,'.',3),goTermId;";
	push @statement, "alter table #TABLE# change probability probability double not null;";
	push @statement, "alter table #TABLE# change count count int not null";
	push @statement, "alter table #TABLE# add index(count);";
	push @statement, "alter table #TABLE# add index(sccs);";
	push @statement, "alter table #TABLE# add index(probability);";
	push @statement, "alter table #TABLE# add index(goTermId);";
	push @statement, "alter table #TABLE# add index(term_type);";
	push @statement, "alter table #TABLE# add column scop_id int not null after sccs;";
	push @statement, "update #TABLE# p inner join scop.scop_des on p.sccs = scop_des.sccs set p.scop_id = scop_des.id;";
	push @statement, "alter table #TABLE# add index(scop_id);";
	for my $stat (@statement) {
		printf "$stat\n";
		$RESULT->querydo($stat);
	}
	my $aryref = $RESULT->querycol("SELECT DISTINCT sccs FROM #TABLE#");
	my $log;
	$log .= sprintf "Found %d sccs\n", $#$aryref+1;
	for my $sccs (@$aryref) {
		next unless $sccs;
		for my $type (qw( molecular_function biological_process cellular_component )) {
			my $count = $RESULT->queryrow("SELECT SUM(count) FROM #TABLE# WHERE term_type = '$type' AND sccs = '$sccs'");
			#$log .= sprintf "%s %s %s\n", $sccs,$type,$count;
			next unless $count;
			$RESULT->querydo("UPDATE #TABLE# SET probability = count/$count WHERE term_type = '$type' AND sccs = '$sccs'");
		}
		#last;
	}
	return $log;
}
#sub bddbResult_192 {
sub bddbResult_164 {
	my(%param)=@_;
	confess "Broken\n";
	require DDB::DATABASE::SCOP;
	my $RESULT = $param{result};
	my @statement;
	push @statement, "DROP TABLE #TABLE#";
	push @statement, "CREATE TABLE #TABLE# SELECT structureMcmData.id,prediction_sequence_key AS sequence_key,prediction_sequence_key AS domain,'abi' AS method,experiment_sccs,sf,fa,MAX(probability) AS probability FROM bddbResult.structureMcmData INNER JOIN scop.scop_cla ON experiment_sccs = sccs WHERE probability > 0.2 GROUP BY prediction_sequence_key,experiment_sccs";
	push @statement, "ALTER TABLE #TABLE# ADD COLUMN sf_probability double not null";
	for my $stat (@statement) {
		printf "$stat\n";
		$RESULT->querydo($stat);
	}
	my $update_sfprob = 1;
	my $log;
	my $SFPROBRESULT = DDB::RESULT->get_object( id => 156 );
	my $sfprob = $SFPROBRESULT->get_data();
	if ($update_sfprob) {
		#my $col = $RESULT->querycol("SELECT DISTINCT domain FROM #TABLE# WHERE method IN ('abi')");
		my $col = $RESULT->querycol("SELECT DISTINCT domain FROM #TABLE# WHERE method IN ('abi') GROUP BY domain HAVING SUM(sf_probability) = 0");
		$log .= sprintf "==> SFPROB UPDATE <==\n%d abi domains\n", $#$col+1;
		for my $domain (@$col) {
			eval {
				my $sequence_key = $RESULT->queryrow("SELECT sequence_key FROM #TABLE# WHERE domain = '$domain'");
				my $ctot = $RESULT->queryrow("SELECT SUM(probability) FROM #TABLE# WHERE domain = '$domain'");
				printf "%s %s %s\n", $domain, $ctot,$sequence_key;
				my $cptot;
				my $factor= 0.8;
				#my $factor= 0.0;
				if ($ctot > $factor) {
					$cptot = $factor;
					$RESULT->querydo("UPDATE #TABLE# SET sf_probability = probability/$ctot*$cptot WHERE domain = '$domain'");
				} else {
					$cptot = $ctot;
					$RESULT->querydo("UPDATE #TABLE# SET sf_probability = probability WHERE domain = '$domain' AND probability > 0");
				}
				for my $row (@$sfprob) {
					my %data;
					$data{sequence_key} = $sequence_key;
					$data{domain} = $domain;
					$data{method} = 'abi';
					$data{sf} = DDB::DATABASE::SCOP->get_classification_from_sccs( sccs => $row->[0] );
					$data{fa} = -1;
					$data{probability} = -1;
					$data{sf_probability} = $row->[2]*(1-$cptot);
					my $currprob = $RESULT->queryrow("SELECT sf_probability FROM #TABLE# WHERE domain = '$data{domain}' AND sf = $data{sf}");
					unless ($currprob) {
						$log .= "Not present\n" if $param{debug} > 2;
						$RESULT->insert( %data );
					} else {
						$RESULT->querydo("UPDATE #TABLE# SET sf_probability = sf_probability+$data{sf_probability} WHERE domain = '$data{domain}' AND sf = $data{sf}");
					}
				}
				#$log .= sprintf "$domain $ctot $cptot\n";
			};
			if ($@) {
				confess "$log\n$@\n";
			}
		}
	}
	return $log;
}
sub bddbResult_167 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my @statement;
	push @statement, "DROP TABLE #TABLE#";
	push @statement, "CREATE TABLE #TABLE# SELECT term.acc,term.id AS goterm_id,COUNT(*) AS count FROM $DDB::DATABASE::MYGO::obj_table_assoc INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON term.id = term_id WHERE term_type = 'biological_process' GROUP BY term.acc";
	push @statement, "ALTER TABLE #TABLE# ADD COLUMN probability DOUBLE NOT NULL";
	push @statement, "ALTER TABLE #TABLE# ADD UNIQUE(acc)";
	push @statement, "ALTER TABLE #TABLE# ADD UNIQUE(goterm_id)";
	push @statement, "ALTER TABLE #TABLE# ADD INDEX(probability)";
	push @statement, "ALTER TABLE #TABLE# ADD INDEX(count)";
	for my $stat (@statement) {
		printf "$stat\n";
		$RESULT->querydo($stat);
	}
	my $count = $RESULT->queryrow("SELECT SUM(count) FROM #TABLE#");
	$RESULT->querydo("UPDATE #TABLE# SET probability = count/$count");
}
sub bddbResult_169 {
	my(%param)=@_;
	my $RESULT = $param{result};
	open IN, "</home/bench/newProcessPseudocountsNoZero.txt";
	while (<IN>) {
		my $line = $_;
		my @parts = split /\t/, $line;
		confess "Wrong number of parts for line $line\n" unless $#parts == 4;
		my %data = (scop_id => $parts[0], goacc => $parts[1], p_P => $parts[2], p_PSF => $parts[3], p_PSF_P => $parts[4] );
		$RESULT->insertignore( %data );
	}
	close IN;
}
sub bddbResult_179 {
	my(%param)=@_;
	my $RESULT = $param{result};
	open IN, "</home/bench/newFunctionPseudocountsNoZero.txt";
	while (<IN>) {
		my $line = $_;
		my @parts = split /\t/, $line;
		confess "Wrong number of parts for line $line\n" unless $#parts == 4;
		my %data = (scop_id => $parts[0], goacc => $parts[1], p_F => $parts[2], p_FSF => $parts[3], p_FSF_F => $parts[4] );
		$RESULT->insertignore( %data );
	}
}
sub bddbResult_184 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::FILE;
	my $FILE = DDB::FILE->get_object( id => 10 ); # with background
	#my $FILE = DDB::FILE->get_object( id => 9 ); # without background
	my $content = $FILE->get_file_content();
	my @lines = split /\n/, $content;
	for my $line (@lines) {
		my @parts = split /\t/, $line;
		confess "Wrong number of parts for line $line\n" unless $#parts == 4;
		my %data = (scop_id => $parts[0], goacc => $parts[1], p_L => $parts[2], p_LSF => $parts[3], p_LSF_L => $parts[4] );
		$RESULT->insertignore( %data );
	}
}
sub bddbResult_191 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==0) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		#$RESULT->querydo("CREATE TABLE #TABLE# (`id` int(11) NOT NULL auto_increment, `len` varchar(50) NOT NULL default '', `a_a6` int(11) NOT NULL default '0', `a_b6` int(11) NOT NULL default '0', `b_a6` int(11) NOT NULL default '0', `b_b6` int(11) NOT NULL default '0', `ab_a6` int(11) NOT NULL default '0', `ab_b6` int(11) NOT NULL default '0', PRIMARY KEY (`id`), UNIQUE KEY `len` (`len`)) ENGINE=MyISAM DEFAULT CHARSET=latin1");
		$RESULT->querydo("CREATE TABLE #TABLE# (`id` int(11) NOT NULL auto_increment, `category` varchar(50) NOT NULL default '', total int not null,top1 int not null,top5 int not null,best_in_set int not null,mcm5 int not null, PRIMARY KEY (`id`), UNIQUE KEY `category` (`category`)) ENGINE=MyISAM DEFAULT CHARSET=latin1");
	}
	$RESULT->insertignore( category => 'all' );
	for my $i ('1-100','101-120','121-150','151-200') {
		$RESULT->insertignore( category => $i );
		for my $c ("'a'","'b'","'c','d'") {
			for my $t (qw( a b )) {
				my $tc = $c;
				$tc =~ s/\W//g;
				$tc = 'ab' if $tc eq 'cd';
				$RESULT->insertignore( category => $tc );
				my $cat = sprintf "%s:%s",$i,$tc;
				$RESULT->insertignore( category => $cat );
				my $count;
				#$count = $RESULT->queryrow( sprintf "SELECT COUNT(DISTINCT r.sequence_key) FROM #TABLE208# r INNER JOIN #TABLE95# t ON r.sequence_key = t.sequence_key INNER JOIN scop.scop_cla ON scop_px = classification WHERE len >= %s AND len <= %s AND LEFT(scop_cla.sccs,1) IN (%s)", (split /-/, $i),$c);
				#$RESULT->querydo( sprintf "UPDATE #TABLE# SET total = %d WHERE category = \"%s\"", $count, $cat);
				#$count = $RESULT->queryrow( sprintf "SELECT COUNT(DISTINCT r.sequence_key) FROM #TABLE208# r INNER JOIN #TABLE95# t ON r.sequence_key = t.sequence_key INNER JOIN scop.scop_cla ON scop_px = classification INNER JOIN #TABLE117# t117 ON r.sequence_key = t117.prediction_sequence_key WHERE len >= %s AND len <= %s AND LEFT(scop_cla.sccs,1) IN (%s) AND corrall_prob >= 0.8 AND correct_superfamily = 1", (split /-/, $i),$c);
				#$RESULT->querydo( sprintf "UPDATE #TABLE# SET mcm5 = %d WHERE category = \"%s\"", $count, $cat);
				$count = $RESULT->queryrow( sprintf "SELECT COUNT(DISTINCT r.sequence_key) FROM #TABLE208# r INNER JOIN #TABLE95# t ON r.sequence_key = t.sequence_key INNER JOIN scop.scop_cla ON scop_px = classification WHERE min_mxlge <= -6 AND len >= %s AND len <= %s AND LEFT(scop_cla.sccs,1) IN (%s)", (split /-/, $i),$c);
				$RESULT->querydo( sprintf "UPDATE #TABLE# SET best_in_set = %d WHERE category = \"%s\"", $count, $cat);
				#$RESULT->insertignore( len => $i );
				#my $count = $RESULT->queryrow( sprintf "SELECT COUNT(DISTINCT r.sequence_key) FROM #TABLE208# r INNER JOIN #TABLE95# t ON r.sequence_key = t.sequence_key INNER JOIN scop.scop_cla ON scop_px = classification WHERE min_mxlge %s -6 AND len >= %s AND len <= %s AND LEFT(scop_cla.sccs,1) IN (%s)", ($t eq 'a') ? '<=' : '>', (split /-/, $i),$c);
				#$RESULT->querydo( sprintf "UPDATE #TABLE# SET %s_%s6 = %d WHERE len = \"%s\"", $tc, $t, $count, $i);
			}
		}
	}
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT '1-100',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '1-100:%'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT '101-120',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '101-120:%'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT '121-150',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '121-150:%'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT '151-200',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '151-200:%'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT 'a',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '%:a'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT 'b',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '%:b'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT 'ab',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '%:ab'");
	$RESULT->querydo("REPLACE #TABLE# (category,total,top1,top5,best_in_set,mcm5) SELECT 'all',SUM(total),SUM(top1),SUM(top5),SUM(best_in_set),SUM(mcm5) FROM #TABLE# WHERE category LIKE '%:%'");
}
sub bddbResult_206 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::PROTEIN;
	require DDB::FILESYSTEM::OUTFILE;
	my $aryref = DDB::PROTEIN->get_ids( experiment_key => 6 );
	for my $id (@$aryref) {
		eval {
			my $PROTEIN = DDB::PROTEIN->get_object( id => $id );
			my $outfile_aryref = DDB::FILESYSTEM::OUTFILE->get_ids( sequence_key => $PROTEIN->get_sequence_key() );
			if ($#$outfile_aryref == 0) {
				my $OUTFILE = DDB::FILESYSTEM::OUTFILE->get_object( id => $outfile_aryref->[0] );
				my $outfile = $OUTFILE->get_outfile();
				my $directory = $outfile;
				$directory =~ s/gz$/p/ || die "$id Cannot replace extension for $outfile...\n";
				die "$id Cannot find directory: $directory\n" unless -d $directory;
				my $clusterfile = sprintf "%s/data.cluster", $directory;
				die "$id Cannot find clusterfile $clusterfile\n" unless -f $clusterfile;
				#printf "Found sequence_key %d outfiles: %d; first: %d. cluster: %s\n", $PROTEIN->get_sequence_key(), $#$outfile_aryref+1,$outfile_aryref->[0],$clusterfile;
				my $get = 0;
				open IN, "<$clusterfile";
				while (<IN>) {
					chomp;
					next if $_ =~ /^\s*$/;
					last if $_ =~ /CLUSTER MEMBERS/;
					if ($get) {
						my %data;
						$data{sequence_key} = $PROTEIN->get_sequence_key();
						($data{cluster_nr},$data{decoy_index},$data{decoy_name},$data{cluster_size}) = $_ =~ /^(\d+)\:\s+(\d+),([^\s]+)\s+(\d+)\s+/;
						die "$id Could not parse $_\n" unless $data{decoy_index};
						$RESULT->insert( %data );
					}
					$get = 1 if $_ eq '#: center size cluster-cluster-rmsds';
				}
				close IN;
			} else {
				die sprintf "$id Wrong number of outfiles: %d\n", $#$outfile_aryref+1;
			}
		};
		warn "Fail: $@\n" if $@;
	}
}
sub bddbResult_237 {
	my(%param)=@_;
	my $RESULT = $param{result};
	confess "Careful...\n";
	open IN, "<final_function_predictions.txt";
	for my $line (<IN>) {
		chomp $line;
		my %data;
		my $rest;
		($data{orf},$data{domain},$data{func_goacc},$data{proc_goacc},$data{loc_goacc},$data{go_prob},$data{sfsum_prob},$data{probability},$rest) = split /\t/, $line;
		confess "Rest: $line\n" if $rest;
		next unless $data{go_prob} >= 0.01 || $data{sfsum_prob} >= 0.01 || $data{probability} >= 0.01;
		$RESULT->insert( %data );
	}
	# alter table bddbResult.finalFunction add column domain_key int not null after sequence_key; alter table bddbResult.finalFunction add index(orf);alter table bddbResult.finalFunction add index(domain);
	# alter table bddbResult.finalFunction add index(func_goacc);alter table bddbResult.finalFunction add index(proc_goacc);alter table bddbResult.finalFunction add index(loc_goacc);alter table bddbResult.finalFunction add index(go_prob);alter table bddbResult.finalFunction add index(sfsum_prob);alter table bddbResult.finalFunction add index(probability);
	# alter table bddbResult.finalFunction add index(sequence_key);
	# create table tmptab select distinct orf from bddbResult.finalFunction;
	#alter table tmptab add column sequence_key int not null;
	#update tmptab inner join bddb.ac2sequence ac on orf = nr_ac set tmptab.sequence_key = ac.sequence_key where db = 'MIPS_2001';
	#alter table test.tmptab add unique(orf,sequence_key);
	# echo "SELECT * FROM test.tmptab" | mysql -s > tmp
	# cat tmp | perl -ane 'printf "UPDATE bddbResult.finalFunction SET sequence_key = %s WHERE orf = \"%s\";\n", $F[1],$F[0]; ' > tmp.sql
	# mysql < tmp.sql
	return '';
}
sub bddbResult_241 {
	my(%param)=@_;
	my $RESULT = $param{result};
	confess "Careful...\n";
}
sub bddbResult_242 {
	my(%param)=@_;
	my $RESULT = $param{result};
	#Hi Lars, your data is uploading to the server In your home directory right
	#now and will be done In about an hour. The file is called dataForLars.txt
	#
	#The columns are:
	#go accession
	#superfamily id
	#P(GO|SF) - this is using pseudocounting
	#P(GO)
	#P(GO|SF) / P(GO)
	#
	#All of this is builting using Astral and using the method I've been using of
	#including children nodes In the counts.
	#
	open IN, "<dataForLars.txt";
	while (<IN>) {
		chomp;
		my %data;
		#printf "%s\n", $_;
		my $rest;
		($data{goacc},$data{scop_id},$data{p_gosf},$data{p_go},$data{p_gosf_go},$rest) = split /\t/, $_;
		confess $_ if $rest;
		$RESULT->insertignore( %data );
		#print %data;
	}
	close IN;
}
sub bddbResult_246 {
	# try to generate a function background
	# removed...
}
sub bddbResult_249 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RESULT205 = DDB::RESULT->get_object( id => 205 );
	my $RESULT251 = DDB::RESULT->get_object( id => 251 );
	my $seq_aryref = $RESULT205->get_data_column( column => 'domain_sequence_key' );
	require DDB::SEQUENCE;
	require DDB::PROGRAM::MAMMOTH;
	require DDB::PROGRAM::MCM::DECOY;
	require DDB::PROGRAM::MCM::DATA;
	for my $sequence_key (@$seq_aryref) {
		next if $sequence_key == 15206; # Wrong number of rows...
		next if $sequence_key == 16535; # Wrong number of rows...
		next if $sequence_key == 18514; # Wrong number of rows...
		next if $sequence_key == 19327; # Wrong number of rows...
		next if $sequence_key == 19434; # Wrong number of rows...
		next if $sequence_key == 19617; # Wrong number of rows...
		next if $sequence_key == 20056; # Wrong number of rows...
		next if $sequence_key == 23008; # Wrong number of rows...
		next if $sequence_key == 23268; # Wrong number of rows...
		my $SEQ = DDB::SEQUENCE->get_object( id => $sequence_key );
		my $hash = $RESULT251->get_data_row( sequence_key => $SEQ->get_id() );
		unless ($hash->{fl_structure_key}) {
			printf "No full length structure for %s\n", $SEQ->get_id();
			next;
		}
		my @structures;
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{fl_structure_key} );
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{m_structure_key} );
		for my $STRUCT (@structures) {
			printf "Working with domain sequence key: %d structure_key %d ", $sequence_key,$STRUCT->get_id();
			my $in_db = $ddb_global{dbh}->selectrow_array(sprintf "SELECT COUNT(*) FROM bddbResult.yeastSolved WHERE sequence_key = %d AND structure_key = %d",$sequence_key,$STRUCT->get_id());
			if ($in_db) {
				if (1==0) {
					printf "Exists, still continue...\n";
				} else {
					printf "Exists, go to next...\n";
					next;
				}
			}
			print "\n";
			my $solved_info = $hash->{solved_info} || confess "No information\n";
			# get all data decoys associated with this sequence
			my $mcmdecoy_aryref = DDB::PROGRAM::MCM::DECOY->get_ids( sequence_key => $SEQ->get_id() );
			confess sprintf "Want 10 decoys; found %d\n",$#$mcmdecoy_aryref+1 unless $#$mcmdecoy_aryref > 9;
			my $highmammoth = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			my $nfail2 = 0;
			my $npass2 = 0;
			my %match_mcm;
			for my $id (@$mcmdecoy_aryref) {
				my $MAMMOTH = DDB::PROGRAM::MAMMOTH->new( e_structure_object => $STRUCT, mcmdecoy_key => $id );
				eval {
					$MAMMOTH->run();
				};
				if ($@) {
					warn $@;
					$nfail2++;
				} else {
					$npass2++;
				}
				$match_mcm{ $id } = $MAMMOTH;
				# store the best match between a native and a decoy In highmammoth
				$highmammoth = $MAMMOTH if $MAMMOTH->get_zscore() > $highmammoth->get_zscore();
			}
			confess "None passed\n" if $npass2 == 0;
			my $mcmdata_aryref = DDB::PROGRAM::MCM::DATA->get_ids( sequence_key => $SEQ->get_id() );
			my @mcmdata;
			my $high1 = DDB::PROGRAM::MCM::DATA->new( probability => -1 );
			my $high2;
			my $high3 = DDB::PROGRAM::MCM::DATA->new( probability => -1 );
			my %match;
			my $nfailed = 0;
			for my $id (@$mcmdata_aryref) {
				my $DATA = DDB::PROGRAM::MCM::DATA->get_object( id => $id );
				my $pid = $DATA->get_experiment_file();
				$pid =~ s/\.pdb//;
				my $MAMMOTH = DDB::PROGRAM::MAMMOTH->new( e_structure_object => $STRUCT, p_structure_key => $pid );
				eval {
					$MAMMOTH->run();
					$match{ $DATA->get_id() } = $MAMMOTH;
					$high2 = $DATA unless $high2;
					$high2 = $DATA if $MAMMOTH->get_zscore() > $match{ $high2->get_id() }->get_zscore();
				};
				if (1==0 && $@) {
					confess $@;
				}
				$nfailed++ if $@;
				$high1 = $DATA if $DATA->get_probability() > $high1->get_probability();
				#$high1 = $DATA if $DATA->get_probability() > $high1->get_probability();
				push @mcmdata, $DATA;
			}
			my $DECOY = DDB::PROGRAM::MCM::DECOY->get_object( id => $highmammoth->get_mcmdecoy_key() );
			for my $DATA (@mcmdata) {
				if ($DATA->get_mcm_decoy_key() == $DECOY->get_id()) {
					$high3 = $DATA if $DATA->get_probability() > $high3->get_probability();
					#$high3 = $DATA if $DATA->get_probability() > $high3->get_probability();
				}
			}
			printf "%d '%s' '%s' '%s' '%s'\n", $#mcmdata+1,ref $highmammoth, ref $high1, ref $high2, ref $high3;
			unless ($match{ $high1->get_id() }) {
				warn sprintf "NOGOOD (high1): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high1->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			unless ($match{ $high2->get_id() }) {
				warn sprintf "NOGOOD (high2): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high2->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			unless ($match{ $high3->get_id() }) {
				warn sprintf "NOGOOD (high3): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high3->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			my %data;
			$data{sequence_key} = $sequence_key;
			$data{structure_key} = $STRUCT->get_id();
			$data{solved_info} = $solved_info;
			$data{n_mcm_data} = $#mcmdata+1;
			$data{n_mcm_failed} = $nfailed;
			# highest mammoth match
			$data{mh_mcmDecoy_key} = $DECOY->get_id();
			$data{mh_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $DECOY->get_id(),$STRUCT->get_id();
			$data{mh_zscore} = $highmammoth->get_zscore();
			# highest probability
			$data{prob_mcmData_key} = $high1->get_id();
			$data{prob_prob} = $high1->get_probablity();
			#$data{prob_prob} = $high1->get_probability();
			$data{prob_mcmDecoy_key} = $high1->get_mcm_decoy_key();
			$data{prob_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high1->get_mcm_decoy_key(),$STRUCT->get_id();
			$data{prob_zscore} = $match_mcm{ $high1->get_mcm_decoy_key() }->get_zscore();
			#$data{prob_zscore} = $match{ $high1->get_id() }->get_zscore();
			$data{n2m_mcmData_key} = $high2->get_id();
			$data{n2m_prob} = $high2->get_probability();
			#$data{n2m_prob} = $high2->get_probability();
			$data{n2m_mcmDecoy_key} = $high2->get_mcm_decoy_key();
			$data{n2m_mammoth} = sprintf "structure_key:%d-structure_key:%d", $match{ $high2->get_id() }->get_p_structure_key(),$STRUCT->get_id();
			#$data{n2m_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high2->get_mcm_decoy_key(),$STRUCT->get_id();
			$data{n2m_zscore} = $match{ $high2->get_id() }->get_zscore();
			$data{n2decoy_mcmData_key} = $high3->get_id();
			$data{n2decoy_prob} = $high3->get_probability();
			#$data{n2decoy_prob} = $high3->get_probability();
			$data{n2decoy_mcmDecoy_key} = $high3->get_mcm_decoy_key();
			$data{n2decoy_zscore} = $match{ $high3->get_id() }->get_zscore();
			$data{n2decoy_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high3->get_mcm_decoy_key(),$STRUCT->get_id();
			$RESULT->insertreplace( %data );
		}
	}
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastSolved SET full_length = ''");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastSolved INNER JOIN bddbResult.res205Structures ON yeastSolved.structure_key = fl_structure_key SET full_length = 'yes'");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastSolved INNER JOIN bddbResult.res205Structures ON yeastSolved.structure_key = m_structure_key SET full_length = 'no'");
}
sub bddbResult_250 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RESULT205 = DDB::RESULT->get_object( id => 205 );
	my $RESULT251 = DDB::RESULT->get_object( id => 251 );
	my $seq_aryref = $RESULT205->get_data_column( column => 'domain_sequence_key' );
	require DDB::RESULT;
	require DDB::SEQUENCE;
	require DDB::PROGRAM::MAMMOTH;
	require DDB::PROGRAM::MCM::DECOY;
	require DDB::PROGRAM::MCM::DATA;
	require DDB::PROGRAM::MCM::SUPERFAMILY;
	for my $sequence_key (@$seq_aryref) {
		next if $sequence_key == 11217; # Wrong number of rows...
		next if $sequence_key == 15206; # Wrong number of rows...
		next if $sequence_key == 16535; # Wrong number of rows...
		next if $sequence_key == 18514; # Wrong number of rows...
		next if $sequence_key == 19327; # Wrong number of rows...
		next if $sequence_key == 19434; # Wrong number of rows...
		next if $sequence_key == 19617; # Wrong number of rows...
		next if $sequence_key == 20056; # Wrong number of rows...
		next if $sequence_key == 23008; # Wrong number of rows...
		next if $sequence_key == 23268; # Wrong number of rows...
		my $SEQ = DDB::SEQUENCE->get_object( id => $sequence_key );
		my $hash = $RESULT251->get_data_row( sequence_key => $SEQ->get_id() );
		unless ($hash->{fl_structure_key}) {
			printf "No full length structure for %s\n", $SEQ->get_id();
			next;
		}
		my @structures;
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{fl_structure_key} );
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{m_structure_key} );
		for my $STRUCT (@structures) {
			printf "Working with domain sequence key: %d structure_key %d ", $sequence_key,$STRUCT->get_id();
			my $in_db = $ddb_global{dbh}->selectrow_array(sprintf "SELECT COUNT(*) FROM bddbResult.yeastIntSolved WHERE sequence_key = %d AND structure_key = %d",$sequence_key,$STRUCT->get_id());
			if ($in_db) {
				if (1==0) {
					printf "Exists, still continue...\n";
				} else {
					printf "Exists, go to next...\n";
					next;
				}
			}
			print "\n";
			my %data;
			my $sf_aryref = DDB::PROGRAM::MCM::SUPERFAMILY->get_ids( sequence_key => $SEQ->get_id(), order => 'integrated_norm_probability_desc' );
			$data{sequence_key} = $SEQ->get_id();
			$data{solved_info} = $hash->{solved_info};
			$data{structure_key} = $STRUCT->get_id();
			$data{n_superfam_data} = $#$sf_aryref+1;
			my $SF = DDB::PROGRAM::MCM::SUPERFAMILY->get_object( id => $sf_aryref->[0] );
			my $data_aryref = DDB::PROGRAM::MCM::DATA->get_ids( sequence_key => $SEQ->get_id(), experiment_sf_sccs => $SF->get_sccs() );
			if ($#$data_aryref < 0) {
				printf "No mcm-data sequence_key: %d; sccs: %s\n",$SEQ->get_id(),$SF->get_sccs();
				next;
			}
			$data{sccs} = $SF->get_sccs();
			$data{integrated_norm_probability} = $SF->get_integrated_norm_probability();
			$data{n_mcm_data} = $#$data_aryref+1;
			my $DATA = DDB::PROGRAM::MCM::DATA->get_object( id => $data_aryref->[0] );
			my $DECOY = DDB::PROGRAM::MCM::DECOY->get_object( id => $DATA->get_mcm_decoy_key() );
			$data{max_mcm_prob} = $DATA->get_probability();
			$data{decoy_name} = $DECOY->get_decoy_name();
			my $MAMMOTH = DDB::PROGRAM::MAMMOTH->new( e_structure_object => $STRUCT, mcmdecoy_key => $DECOY->get_id() );
			$MAMMOTH->run();
			$data{mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $DECOY->get_id(),$STRUCT->get_id();
			$data{zscore} = $MAMMOTH->get_zscore();
			$RESULT->insertreplace( %data );
		}
	}
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved SET full_length = ''");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved INNER JOIN bddbResult.res205Structures ON yeastIntSolved.structure_key = fl_structure_key SET full_length = 'yes'");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved INNER JOIN bddbResult.res205Structures ON yeastIntSolved.structure_key = m_structure_key SET full_length = 'no'");
	$ddb_global{dbh}->do("UPDATE bddbResult.yeastIntSolved SET length_group = ''");
	$ddb_global{dbh}->do("UPDATE bddbResult.yeastIntSolved INNER JOIN bddb.sequence ON sequence_key = sequence.id SET length_group = 'short' WHERE LENGTH(sequence) < 80");
	$ddb_global{dbh}->do("UPDATE bddbResult.yeastIntSolved INNER JOIN bddb.sequence ON sequence_key = sequence.id SET length_group = 'medium' WHERE LENGTH(sequence) >= 80 AND LENGTH(sequence) < 120");
	$ddb_global{dbh}->do("UPDATE bddbResult.yeastIntSolved INNER JOIN bddb.sequence ON sequence_key = sequence.id SET length_group = 'long' WHERE LENGTH(sequence) >= 120 AND LENGTH(sequence) < 150");
	$ddb_global{dbh}->do("UPDATE bddbResult.yeastIntSolved INNER JOIN bddb.sequence ON sequence_key = sequence.id SET length_group = 'giant' WHERE LENGTH(sequence) >= 150");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved SET improvement = ''");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved SET improvement = 'yes' WHERE integrated_norm_probability >= max_mcm_prob");
	$ddb_global{dbh}->do(sprintf "UPDATE bddbResult.yeastIntSolved SET improvement = 'no' WHERE integrated_norm_probability < max_mcm_prob");
	my $sthAll = $ddb_global{dbh}->prepare(sprintf "SELECT id,solved_info FROM %s.%s WHERE solved_info REGEXP 'pdbid:'",$RESULT->get_resultdb(),$RESULT->get_table_name() );
	$sthAll->execute();
	printf "%d rows\n", $sthAll->rows();
	while (my($id,$solved) = $sthAll->fetchrow_array()) {
		my ($pdb) = $solved =~ /pdbid\: (\w+)/;
		my $sthGet = $ddb_global{dbh}->prepare("SELECT DISTINCT sccs FROM scop.scop_cla WHERE pdb = '$pdb'");
		$sthGet->execute();
		my $rows = $sthGet->rows();
		my $native_sccs = '';
		if ($rows == 0) {
			$native_sccs = sprintf "No classification for %s", $pdb;
		} elsif ($rows == 1) {
			$native_sccs = $sthGet->fetchrow_array();
		} else {
			$native_sccs = 'Multi: ';
			while (my($sccs) = $sthGet->fetchrow_array()) {
				$native_sccs .= $sccs." ";
			}
		}
		printf "%d %s %d rows %s\n", $id,$pdb,$sthGet->rows(),$native_sccs;
		my $sthUpdate = $ddb_global{dbh}->do( sprintf "UPDATE %s.%s SET native_sccs = '%s' WHERE id = %d", $RESULT->get_resultdb(),$RESULT->get_table_name(),$native_sccs,$id);
	}
	$RESULT->querydo("UPDATE #TABLE# s INNER JOIN bddb.mcmIntegration ON s.sequence_key = mcmIntegration.sequence_key SET s.contaminated = 'yes' WHERE goacc IN ('GO:0000004','GO:0005554','GO:0008372')");
	$RESULT->querydo("UPDATE #TABLE# SET mcmdecoy_key = SUBSTRING_INDEX(SUBSTRING_INDEX(mammoth,'-',1),':',-1) WHERE mcmdecoy_key = 0");
	return '';
}
sub bddbResult_251 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RESULT205 = DDB::RESULT->get_object( id => 205 );
	my $seq_aryref = $RESULT205->get_data_column( column => 'domain_sequence_key' );
	require DDB::RESULT;
	require DDB::SEQUENCE;
	require DDB::PROGRAM::MAMMOTH;
	require DDB::STRUCTURE;
	for my $sequence_key (@$seq_aryref) {
		#next unless $sequence_key == 11278;
		printf "Working with domain sequence key: %d... ", $sequence_key;
		my $in_db = $ddb_global{dbh}->selectrow_array(sprintf "SELECT COUNT(*) FROM %s.%s WHERE sequence_key = $sequence_key",$RESULT->get_resultdb(),$RESULT->get_table_name());
		if ($in_db) {
			printf "Exists, will go to the next...\n";
			next;
		} else {
			print "\n";
		}
		eval {
			my $SEQ = DDB::SEQUENCE->get_object( id => $sequence_key );
			my $struct_aryref = DDB::STRUCTURE->get_ids( sequence_key => $SEQ->get_id(), structure_type => 'native' );
			my $STRUCT;
			my %data;
			$data{sequence_key} = $SEQ->get_id();
			if ($#$struct_aryref == 0) {
				$STRUCT= DDB::STRUCTURE->get_object( id => $struct_aryref->[0] );
				$data{solved_info} = 'native structure';
				$data{fl_sequence_key} = $STRUCT->get_sequence_key();
				$data{fl_structure_key} = $STRUCT->get_id();
				$data{m_sequence_key} = $STRUCT->get_sequence_key();
				$data{m_structure_key} = $STRUCT->get_id();
			} elsif ($#$struct_aryref == -1) {
				require DDB::PROGRAM::CLUSTAL;
				require DDB::DATABASE::PDB;
				require DDB::DATABASE::PDB::SEQRES;
				require DDB::PROGRAM::PDBUTIL;
				my $data = $RESULT205->get_data( columns => ['subject_id','domain_sequence_key','max_identity'], where => [(sprintf "domain_sequence_key = %d", $SEQ->get_id())] );
				printf "%s dom.seq.key: %s\n", $data->[0]->[0],$data->[0]->[1];
				confess sprintf "Wrong!! %d %d\n", $data->[0]->[1],$SEQ->get_id() unless $data->[0]->[1] == $SEQ->get_id();
				my $seqres_aryref = DDB::DATABASE::PDB::SEQRES->get_ids( label => $data->[0]->[0] ); # will fail; used to use DDB::STRUCTURE::PDB
				my $PDBCHAIN = DDB::DATABASE::PDB::SEQRES->get_object( id => $seqres_aryref->[0] );
				printf "%s %s %s\n" ,$PDBCHAIN->get_pdb_id(),$PDBCHAIN->get_chain(),$PDBCHAIN->get_sequence();
				my $PDB = $PDBCHAIN->get_pdb();
				my $dir = get_tmpdir();
				printf "DIR: $dir\n";
				$PDB->export_file( name => 'full' );
				my $UTIL = DDB::PROGRAM::PDBUTIL->new();
				$UTIL->remove_all_but_chain( file => 'full', outfile => 'onlychain', chain => $PDBCHAIN->get_chain() );
				$STRUCT = DDB::STRUCTURE->new();
				DDB::STRUCTURE->parse_file( structure => $STRUCT, file => 'onlychain' );
				$data{solved_info} = sprintf "seqlen: %d pdbchainlen: %d; pdbid: %s chain: %s; percent: %s",length($SEQ->get_sequence()),length($PDBCHAIN->get_sequence()),$PDBCHAIN->get_pdb_id(),$PDBCHAIN->get_chain(),$data->[0]->[2];
				$STRUCT->add( ignore => 1, add_sequence => 1, process => 1 );
				$data{fl_sequence_key} = $STRUCT->get_sequence_key();
				$data{fl_structure_key} = $STRUCT->get_id();
				if (length($SEQ->get_sequence())*1.5 > length($PDBCHAIN->get_sequence())) {
					$data{m_sequence_key} = $STRUCT->get_sequence_key();
					$data{m_structure_key} = $STRUCT->get_id();
				} else {
					require DDB::PROGRAM::BLAST::PAIR;
					my $BLAST = DDB::PROGRAM::BLAST::PAIR->new();
					my $PDBSEQ = DDB::SEQUENCE->get_object( id => $STRUCT->get_sequence_key() );
					$BLAST->add_sequence( $SEQ );
					$BLAST->add_sequence( $PDBSEQ );
					print $BLAST->execute();
					if ($BLAST->get_subject_stop()-$BLAST->get_subject_start()+1 > 0.60*length($SEQ->get_sequence())) {
						printf "%s %s\n", $BLAST->get_subject_start(), $BLAST->get_subject_stop();
						my $SUB = $STRUCT->get_substructure( start => $BLAST->get_subject_start(), stop => $BLAST->get_subject_stop() );
						#print $SUB;
						$SUB->add( ignore => 1 );
						$data{m_sequence_key} = $SUB->get_sequence_key();
						$data{m_structure_key} = $SUB->get_id();
					} else {
						printf "SubjectStart: %s SubjectStop: %s Length: %s\n", $BLAST->get_subject_start(), $BLAST->get_subject_stop(),length($SEQ->get_sequence());
						#printf "RAW%s\nRAWEND\n", $BLAST->get_raw_output();
						confess "Too little coverage...\n";
					}
				}
			} else {
				confess sprintf "Fix %d\n",$#$struct_aryref+1 unless $#$struct_aryref == 0;
			}
			printf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $data{$_}; }keys %data;
			$RESULT->insert( %data );
		};
		warn "FAILED: $@\n" if $@;
	}
}
sub bddbResult_252 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	my $RES158 = DDB::RESULT->get_object( id => 158 );
	if (1==1) {
		$ddb_global{dbh}->do(sprintf "DROP TABLE IF EXISTS %s.%s", $RESULT->get_resultdb(),$RESULT->get_table_name());
		$ddb_global{dbh}->do(sprintf "CREATE TABLE %s.%s (id int not null auto_increment primary key,sequence_key int not null,unique(sequence_key),cutoff double not null,int_rank int not null,int_prob double not null, struct_rank int not null,struct_prob double not null, func_rank int not null,func_prob double not null)", $RESULT->get_resultdb(),$RESULT->get_table_name());
	}
	my $seq_aryref = $RES158->get_data_column( column => 'sequence_key' );
	printf "Number of single-domain sequences: %d\n", $#$seq_aryref+1;
	my $cutoff = 0.01;
	for my $seq (@$seq_aryref) {
		my $statement = sprintf "SELECT COUNT(*) FROM %s.%s WHERE sequence_key = %d",$RESULT->get_resultdb(),$RESULT->get_table_name(),$seq;
		my $count = $ddb_global{dbh}->selectrow_array($statement);
		next if $count;
		my $max = $ddb_global{dbh}->selectrow_array("SELECT MAX(maxFraction) FROM test.poffevaluation_noyeast_20051028_nogeneral_abinitio WHERE sequence_key = $seq");
		next unless $max && $cutoff <= $max;
		my %data;
		for my $mode (qw(int struct func)) {
			my $table = 'poffevaluation_noyeast_20051028_nogeneral_abinitio' if $mode eq 'int';
			$table = 'poffevaluation_sfbackground_noyeast_20051028_abinitio' if $mode eq 'struct';
			$table = 'poffevaluation_gobackground_noyeast_20051028_abinitio' if $mode eq 'func';
			my $sth = $ddb_global{dbh}->prepare("SELECT PofF,maxFraction FROM test.$table WHERE sequence_key = $seq ORDER BY PofF DESC");
			$sth->execute();
			$data{$mode.'_rank'} = 0;
			$data{sequence_key} = $seq;
			while (my($prob,$frac) = $sth->fetchrow_array()) {
				#printf "%s %s\n", $prob,$frac;
				#$data{'max_'.$mode.'_prob'} = $prob if $data{$mode.'_rank'} == 0;
				$data{$mode.'_prob'} = $prob;
				#$data{$mode.'_frac'} = $frac;
				$data{$mode.'_rank'}++;
				last if $frac >= $cutoff;
			}
		}
		$data{cutoff} = $cutoff;
		printf "%s\n", join ", ", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
		$RESULT->insertreplace( %data );
		#last;
	}
}
sub bddbResult_253 {
	# removed....
}
sub bddbResult_254 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==1) {
		$ddb_global{dbh}->do(sprintf "DROP TABLE IF EXISTS %s.%s", $RESULT->get_resultdb(),$RESULT->get_table_name());
		$ddb_global{dbh}->do(sprintf "CREATE TABLE %s.%s ( `id` int(11) NOT NULL auto_increment, `sequence_key` int(11) NOT NULL default '0', `domain` varchar(100) NOT NULL default '', `method` varchar(50) NOT NULL default '', `sf` int(11) NOT NULL default '0', `fa` int(11) NOT NULL default '0', `probability` double NOT NULL default '0', `sf_probability` double NOT NULL default '0', `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `domain` (`domain`,`sf`), KEY `probability` (`probability`), KEY `sf_probability` (`sf_probability`), KEY `method` (`method`), KEY `sequence_key` (`sequence_key`)) ENGINE=MyISAM DEFAULT CHARSET=latin1", $RESULT->get_resultdb(),$RESULT->get_table_name());
		my $statement = sprintf "INSERT %s.%s SELECT * FROM bddbResult.yeastSFprediction WHERE method IN ('orfeus','pcons','pdbblast')",$RESULT->get_resultdb(),$RESULT->get_table_name();
		$ddb_global{dbh}->do($statement);
	}
	my $log = '';
	my $dom_aryref = $ddb_global{dbh}->selectcol_arrayref(sprintf "SELECT DISTINCT domain FROM bddbResult.yeastSFprediction WHERE method IN ('abi') AND probability != -1");
	#my $dom_aryref = [12589];
	$log .= sprintf "%d domains\n", $#$dom_aryref+1;
	require DDB::DOMAIN;
	require DDB::PROGRAM::MCM::DATA;
	require DDB::DATABASE::SCOP;
	for my $domain_id (@$dom_aryref) {
		my $DOMAIN = DDB::DOMAIN->get_object( id => $domain_id );
		my $aryref = DDB::PROGRAM::MCM::DATA->get_ids( sequence_key => $DOMAIN->get_domain_sequence_key(), order => 'probability DESC', limit => 5, probabilityover => 0.2 );
		my %hash;
		my $sum = 0;
		$log .= sprintf "domain: %d sequence:key %d/%d %d entries\n", $DOMAIN->get_id(),$DOMAIN->get_parent_sequence_key(),$DOMAIN->get_domain_sequence_key(),$#$aryref+1;
		for my $id (@$aryref) {
			my $DATA = DDB::PROGRAM::MCM::DATA->get_object( id => $id );
			my $sccs = $DATA->get_experiment_sccs();
			eval {
				my $sf = DDB::DATABASE::SCOP->get_id_from_sccs( sccs => (join ".", (split /\./, $sccs)[0..2]) );
				unless ($hash{$sf}) {
					$sum += $DATA->get_probability();
					$hash{$sf} = $DATA->get_probability();
				}
			};
			warn ((split /\n/, $@)[0]) if $@;
			#$log .= sprintf "%s %s %s\n",$sccs,$sf ,$DATA->get_probability();
		}
		for my $key (keys %hash) {
			my %data;
			$data{probability} = $hash{$key};
			$data{sf} = $key;
			$data{fa} = '';
			$data{method} = 'abi';
			$data{sequence_key} = $DOMAIN->get_parent_sequence_key();
			$data{domain} = $DOMAIN->get_id();
			if ($sum > 1) {
				$hash{$key} /= $sum;
			}
			$data{sf_probability} = $hash{$key};
			#$log .= sprintf "%s %s\n", $key, $hash{$key};
			$RESULT->insert( %data );
		}
		#last;
	}
	return $log;
}
sub bddbResult_256 {
	my(%param)=@_;
	# replaced by ginzu2yeastrc code
}
sub bddbResult_257 {
	my(%param)=@_;
	my $RESULT = $param{result};
	#warn "Disabled..\n";
	#return '';
	require DDB::RESULT;
	#my $RES158 = DDB::RESULT->get_object( id => 158 );
	if (1==0) {
		$ddb_global{dbh}->do(sprintf "DROP TABLE IF EXISTS %s.%s", $RESULT->get_resultdb(),$RESULT->get_table_name());
		$ddb_global{dbh}->do(sprintf "CREATE TABLE %s.%s (id int not null auto_increment primary key,goary varchar(255) not null,sequence_key int not null,unique(sequence_key,gl_cf,cf,tset,ct),tset int not null,gl_cf int not null,cf double not null,ct int not null,int_r int not null,int_gl int not null,int_prob double not null,int_goacc varchar(15) not null,int_f double(4,2) not null, struct_r int not null,struct_gl int not null,struct_prob double not null,struct_goacc varchar(15) not null,struct_f double(4,2) not null, func_r int not null,func_gl int not null,func_prob double not null,func_goacc varchar(15) not null,func_f double(4,2) not null)", $RESULT->get_resultdb(),$RESULT->get_table_name());
	}
	#my $seq_aryref = $RES158->get_data_column( column => 'sequence_key' );
	my $seq_aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM test.singleDomainAbi");
	printf "Number of single-domain sequences: %d\n", $#$seq_aryref+1;
	my $cutoff = 0.5;
	for my $go_level_cutoff (qw( 0 )) {
		#for my $go_level_cutoff (qw( 1 2 3 4 5 6 )) {
		for my $tset (qw( 1 2 3 )) {
			my $combtable;my $sftable;my $gotable;
			if ($tset == 1) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_combined_20060125 poffevaluation_singledomain_sf_20060125 poffevaluation_singledomain_go_20060125 );
			} elsif ($tset == 2) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_componentonly_combined_20060201 poffevaluation_singledomain_componentonly_sf_20060201 poffevaluation_singledomain_componentonly_go_20060201 );
			} elsif ($tset == 3) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_processonly_combined_20060201 poffevaluation_singledomain_processonly_sf_20060201 poffevaluation_singledomain_processonly_go_20060201 );
			}
			for my $seq (@$seq_aryref) {
				#my $statement = sprintf "SELECT COUNT(*) FROM %s.%s WHERE sequence_key = %d",$RESULT->get_resultdb(),$RESULT->get_table_name(),$seq;
				#my $count = $ddb_global{dbh}->selectrow_array($statement);
				#next if $count;
				require DDB::GO;
				require DDB::DATABASE::MYGO;
				my $max = $ddb_global{dbh}->selectrow_array("SELECT MAX(maxFraction) FROM test.$combtable WHERE sequence_key = $seq");
				my $calcmode = 'any_correct';
				#$calcmode = 'true_func';
				next unless $max && $cutoff <= $max;
				my %data;
				$data{sequence_key} = $seq;
				$data{tset} = $tset;
				$data{cf} = $cutoff;
				$data{ct} = 1;
				$data{gl_cf} = $go_level_cutoff;
				for my $mode (qw(int struct func)) {
					my $table = $combtable if $mode eq 'int';
					$table = $sftable if $mode eq 'struct';
					$table = $gotable if $mode eq 'func';
					my $goaryref = DDB::GO->get_ids( sequence_key => $seq, term_type => 'molecular_function', source => 'sgd200409' );
					confess sprintf "Wrong: %s %s\n",$#$goaryref+1,$seq if $#$goaryref < 0;
					my @go;
					for my $goid (@$goaryref) {
						my $GO = DDB::GO->get_object( id => $goid );
						push @go, $GO->get_acc();
					}
					$data{goary} = join ",",@go;
					if ($calcmode eq 'true_func') {
						my $statement = sprintf "SELECT MIN(rank) FROM test.%s WHERE sequence_key = %s AND fAcc IN ('%s')",$table,$seq,join "','", @go;
						#confess $statement;
						$data{$mode.'_r'} = $ddb_global{dbh}->selectrow_array( $statement );
					} elsif ($calcmode eq 'any_correct') {
						my $sth = $ddb_global{dbh}->prepare("SELECT id,PofF,maxFraction,fAcc FROM test.$table WHERE sequence_key = $seq ORDER BY PofF DESC");
						$sth->execute();
						$data{$mode.'_r'} = 0;
						while (my($id,$prob,$frac,$goacc) = $sth->fetchrow_array()) {
							my $GO;
							eval {
								$GO = DDB::DATABASE::MYGO->get_object( acc => $goacc );
							};
							next if $@;
							#$data{'max_'.$mode.'_prob'} = $prob if $data{$mode.'_r'} == 0;
							$data{$mode.'_prob'} = $prob;
							$data{$mode.'_goacc'} = $goacc;
							$data{$mode.'_f'} = $frac;
							$data{$mode.'_gl'} = $GO->get_level() || 0;
							next if $data{$mode.'_gl'} <= $data{gl_cf};
							$data{$mode.'_r'}++;
							last if $frac >= $cutoff;
							#$ddb_global{dbh}->do(sprintf "UPDATE test.%s SET rank = %d WHERE id = %d", $table,$data{$mode.'_rank'},$id );
						}
					} else {
						confess "Unknown mode: $calcmode\n";
					}
					#last;
				}
				printf "%s\n", join ", ", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
				$RESULT->insert( %data );
				#last;
			}
		}
	}
}
sub bddbResult_258 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	my $RESULT250 = DDB::RESULT->get_object( id => 250 );
	my $RESULT249 = DDB::RESULT->get_object( id => 249 );
	my $RESULT295 = DDB::RESULT->get_object( id => 295 );
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id INT not null primary key auto_increment,ac varchar(50) not null,parent_sequence_key int not null,n_domain int not null,domain_nr int not null,sequence_key int not null, unique(sequence_key),sccs varchar(15) not null,native_sccs varchar(255) not null,native_p_sccs varchar(15) not null,mcm_sccs varchar(15) not null,tier_sccs varchar(15) not null,solved_info varchar(255) not null, int_prob double not null, int_mcm_prob double not null,int_mcmdecoy_key int not null,int_decoy_name varchar(255) not null, int_zscore double not null,int_mammoth varchar(50) not null,mcm_decoy_name varchar(255) not null,mcm_mcmdecoy_key int not null,mcm_prob double not null,mcm_zscore double not null,mcm_mammoth varchar(255) not null,tier_prob double not null, tier_mcmdecoy_key int not null, tier_decoy_name varchar(255) not null, tier_zscore double not null, tier_mammoth varchar(50) not null, conf int not null,structure_key int not null,fl_structure_key int not null,submission_1 enum('no','mcm','int') not null default 'no')");
	}
	my $data = $RESULT250->get_data( columns => ['sequence_key','sccs','integrated_norm_probability','max_mcm_prob','decoy_name','zscore','native_sccs','mammoth','solved_info','structure_key','mcmdecoy_key'], where => ["full_length = 'no'"] );
	for my $row (@$data) {
		#next unless $row->[0] == 2228;
		my %data;
		require DDB::DOMAIN;
		require DDB::SEQUENCE::AC;
		my $aryref = DDB::DOMAIN->get_ids( domain_sequence_key => $row->[0], domain_source => 'ginzu' );
		confess "Wrong number of domains\n" unless $#$aryref == 0;
		my $DOMAIN = DDB::DOMAIN->get_object( id => $aryref->[0] );
		my $daryref = DDB::DOMAIN->get_ids( parent_sequence_key => $DOMAIN->get_parent_sequence_key(), domain_source => 'ginzu' );
		$data{parent_sequence_key} = $DOMAIN->get_parent_sequence_key();
		my $acaryref = DDB::SEQUENCE::AC->get_ids( sequence_key => $DOMAIN->get_parent_sequence_key(), dbarray => ['sgd','misp_2001'] );
		my $AC = ($acaryref->[0]) ? DDB::SEQUENCE::AC->get_object( id => $acaryref->[0] ) : DDB::SEQUENCE::AC->new();
		$data{ac} = sprintf "%s/%s", $AC->get_ac2(),$AC->get_ac();
		$data{sequence_key} = $row->[0];
		$data{sccs} = $row->[1];
		$data{n_domain} = $#$daryref+1;
		$data{domain_nr} = $DOMAIN->get_domain_nr();
		$data{int_prob} = sprintf "%.2f", $row->[2];
		$data{int_mcm_prob} = sprintf "%.2f", $row->[3];
		$data{int_decoy_name} = $row->[4];
		$data{int_mcmdecoy_key} = $row->[10];
		$data{int_zscore} = sprintf "%.2f", $row->[5];
		$data{native_sccs} = $row->[6];
		$data{int_mammoth} = $row->[7];
		$data{solved_info} = $row->[8];
		$data{structure_key} = $row->[9];
		$data{native_p_sccs} = 'change to work with domains';
		my $hash = $RESULT249->get_data_row( sequence_key => $data{sequence_key}, full_length => 'no' );
		eval {
			my $hash2 = $RESULT250->get_data_row( sequence_key => $data{sequence_key}, full_length => 'yes' );
			$data{fl_structure_key} = $hash2->{structure_key};
		};
		$data{fl_structure_key} = $data{structure_key} unless $data{fl_structure_key};
		require DDB::PROGRAM::MCM::DECOY;
		my $DECOY = DDB::PROGRAM::MCM::DECOY->get_object( id => $hash->{prob_mcmDecoy_key} );
		$data{mcm_decoy_name} = $DECOY->get_decoy_name();
		my $statement = "SELECT mcm_decoy_key,experiment_sccs FROM bddb.mcmData WHERE sequence_key = $data{sequence_key} AND decoy_name = '$data{mcm_decoy_name}' AND probability = $hash->{prob_prob}";
		#confess $statement;
		($data{mcm_mcmdecoy_key},$data{mcm_sccs}) = $ddb_global{dbh}->selectrow_array($statement);
		$data{mcm_prob} = sprintf "%.2f", $hash->{prob_prob};
		$data{mcm_zscore} = sprintf "%.2f", $hash->{prob_zscore};
		$data{mcm_mammoth} = $hash->{prob_mammoth} || confess "No value\n";
		#next unless $data{mcm_zscore} <= $data{int_zscore};
		my $hash295 = $RESULT295->get_data_row( sequence_key => $data{sequence_key}, full_length => 'no' );
		require DDB::PROGRAM::MCM::DECOY;
		my $DECOY295 = DDB::PROGRAM::MCM::DECOY->get_object( id => $hash295->{prob_mcmDecoy_key} );
		$data{tier_decoy_name} = $DECOY295->get_decoy_name();
		my $statement295 = "SELECT mcm_decoy_key,experiment_sccs FROM bddb.mcmData WHERE sequence_key = $data{sequence_key} AND decoy_name = '$data{tier_decoy_name}' AND tier_probability = $hash295->{prob_prob}";
		#confess $statement295;
		($data{tier_mcmdecoy_key},$data{tier_sccs}) = $ddb_global{dbh}->selectrow_array($statement295);
		$data{tier_mcmdecoy_key} = -1 unless defined $data{tier_mcmdecoy_key};
		$data{tier_sccs} = -1 unless defined $data{tier_sccs};
		$data{tier_prob} = sprintf "%.2f", $hash295->{prob_prob};
		$data{tier_zscore} = sprintf "%.2f", $hash295->{prob_zscore};
		$data{tier_mammoth} = $hash295->{prob_mammoth} || confess "No value\n";
		if ($data{int_prob} > 0.8 || $data{mcm_prob} > 0.8 || $data{tier_prob} > 0.8) {
			$data{conf} = 1;
		} else {
			$data{conf} = 0;
		}
		$RESULT->insert( %data );
	}
	$RESULT->querydo("UPDATE #TABLE# SET native_sccs = 'd.58.48' WHERE sequence_key = 2228");
	$RESULT->querydo("UPDATE #TABLE# SET native_sccs = 'No classification for 1yws' WHERE sequence_key = 9707");
	$RESULT->querydo("UPDATE #TABLE# SET submission_1 = 'int' WHERE sequence_key IN (17331,16801,15202,15082,2888,2228,1949,11278)");
	$RESULT->querydo("UPDATE #TABLE# SET submission_1 = 'mcm' WHERE sequence_key IN (3666,9364,9707,11346,17793,17864,19615,20280,23873)");
	return "ok\n";
}
sub bddbResult_263 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	require DDB::GO;
	require DDB::DATABASE::MYGO;
	if (1==1) {
		$ddb_global{dbh}->do(sprintf "DROP TABLE IF EXISTS %s.%s", $RESULT->get_resultdb(),$RESULT->get_table_name());
		$ddb_global{dbh}->do(sprintf "CREATE TABLE %s.%s (id int not null auto_increment primary key,goary varchar(255) not null,sequence_key int not null,unique(sequence_key,gl_cf,cf,tset,goacc),tset int not null,gl_cf int not null,cf double not null,ct int not null,goacc varchar(15) not null,sf_goacc varchar(15) not null,go_ano_goacc varchar(15) not null,sf_ano_goacc varchar(15) not null, fraction double(6,2) not null,go_frac double(6,2) not null, sf_frac double(6,2) not null,gosim double(6,2) not null, int_prob double not null, struct_prob double not null, func_prob double not null)",$RESULT->get_resultdb(),$RESULT->get_table_name());
	}
	#my $RES158 = DDB::RESULT->get_object( id => 158 );
	#my $seq_aryref = $RES158->get_data_column( column => 'sequence_key' );
	my $seq_aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM test.singleDomainAbi");
	printf "Number of single-domain sequences: %d\n", $#$seq_aryref+1;
	my $cutoff = 0.5;
	for my $go_level_cutoff (qw( 0 )) { # 1 2 3 4 )) {
		for my $tset (qw( 1 )) { #2 3 )) {
			my $combtable;my $sftable;my $gotable;
			if ($tset == 1) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_combined_20060125 poffevaluation_singledomain_sf_20060125 poffevaluation_singledomain_go_20060125 );
			} elsif ($tset == 2) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_componentonly_combined_20060201 poffevaluation_singledomain_componentonly_sf_20060201 poffevaluation_singledomain_componentonly_go_20060201 );
			} elsif ($tset == 3) {
				($combtable,$sftable,$gotable) = qw( poffevaluation_singledomain_processonly_combined_20060201 poffevaluation_singledomain_processonly_sf_20060201 poffevaluation_singledomain_processonly_go_20060201 );
			}
			for my $seq (@$seq_aryref) {
				my $go_aryref = DDB::GO->get_ids( sequence_key => $seq, source => 'sgd200409' );
				my @goary;
				for my $goid (@$go_aryref) {
					eval {
						my $GO = DDB::GO->get_object( id => $goid );
						push @goary, $GO->get_term();
					};
				}
				if ($#goary < 0) {
					warn "No GO-terms found for $seq\n";
				}
				my $max = $ddb_global{dbh}->selectrow_array("SELECT MAX(maxFraction) FROM test.$combtable WHERE sequence_key = $seq");
				my $calcmode = 'any_correct';
				#$calcmode = 'true_func';
				#next unless $max && $cutoff <= $max;
				my %data;
				$data{sequence_key} = $seq;
				$data{tset} = $tset;
				$data{cf} = $cutoff;
				$data{gl_cf} = $go_level_cutoff;
				my %hash;
				for my $mode (qw(int struct func)) {
					my $table = $combtable if $mode eq 'int';
					$table = $sftable if $mode eq 'struct';
					$table = $gotable if $mode eq 'func';
					my $sth = $ddb_global{dbh}->prepare("SELECT id,PofF,maxFraction,fAcc FROM test.$table WHERE sequence_key = $seq ORDER BY PofF DESC");
					$sth->execute();
					my $rank = 0;
					while (my($id,$prob,$frac,$goacc) = $sth->fetchrow_array()) {
						my $GO;
						eval {
							$GO = DDB::DATABASE::MYGO->get_object( acc => $goacc );
						};
						next if $@;
						next if $GO->get_level() <= $data{gl_cf};
						$rank++;
						$hash{ $GO->get_acc() }->{$mode} = $prob;
						last if $rank > 20;
					}
				}
				my %hash2;
				while (1==1) {
					my $sthgo = $ddb_global{dbh}->prepare("SELECT PofF,fAcc FROM test.$gotable WHERE sequence_key = $seq ORDER BY PofF DESC LIMIT 20");
					my $sthsf = $ddb_global{dbh}->prepare("SELECT PofF,fAcc FROM test.$sftable WHERE sequence_key = $seq ORDER BY PofF DESC LIMIT 20");
					$sthgo->execute();
					require DDB::DATABASE::MYGO;
					while (my($goprob,$goacc)=$sthgo->fetchrow_array()) {
						$sthsf->execute();
						my $max = 0;
						my $go2 = '';
						my $maxprob = 0;
						while(my($sfprob,$sfacc)=$sthsf->fetchrow_array()) {
							my $similarity = DDB::DATABASE::MYGO->get_similarity_by_count( term1 => $goacc, term2 => $sfacc );
							if (defined $similarity && $similarity >= $max) {
								if ($maxprob < $sfprob) {
									$max = $similarity;
									$maxprob = $sfprob;
									$go2 = $sfacc;
									#printf "%s %s %s\n", $go2,$similarity,$maxprob;
								}
							}
						}
						$hash2{$goacc}->{func} = $goprob;
						$hash2{$goacc}->{struct} = $maxprob;
						$hash2{$goacc}->{gosim} = $max;
						$hash2{$goacc}->{sf_goacc} = $go2;
						#last;
					}
					last;
				}
				for my $key (keys %hash2) {
					($hash2{$key}->{int},$hash2{$key}->{fraction}) = $ddb_global{dbh}->selectrow_array("SELECT PofF,maxFraction FROM test.$combtable WHERE sequence_key = $seq AND fAcc = '$key'");
					my $max1=0;
					my $max2=0;
					my $go1;
					my $go2;
					for my $TERM (@goary) {
						my $sim1 = -1;
						eval { $sim1 = DDB::DATABASE::MYGO->get_similarity_by_count( term1 => $key, term2 => $TERM->get_acc() ); };
						my $sim2 = -1;
						eval { $sim2 = DDB::DATABASE::MYGO->get_similarity_by_count( term1 => $hash2{$key}->{sf_goacc}, term2 => $TERM->get_acc() ) };
						if ($sim1 > $max1) {
							$max1 = $sim1;
							$go1 = $TERM->get_acc();
						}
						if ($sim2 > $max2) {
							$max2 = $sim2;
							$go2 = $TERM->get_acc();
						}
					}
					$hash2{$key}->{go_ano_goacc} = $go1;
					$hash2{$key}->{sf_ano_goacc} = $go2;
					$hash2{$key}->{go_frac} = $max1;
					$hash2{$key}->{sf_frac} = $max2;
					$hash2{$key}->{fraction} = ($max2 > $max1) ? $max2 : $max1;
					#delete $hash2{$key} if $hash2{$key}->{gosim} < $cutoff;
				}
				for my $key (keys %hash2) {
					$data{goacc} = $key;
					$data{sf_goacc} = $hash2{$key}->{sf_goacc};
					$data{go_ano_goacc} = $hash2{$key}->{go_ano_goacc} || 'NOTERM';
					$data{sf_ano_goacc} = $hash2{$key}->{sf_ano_goacc} || 'NOTERM';
					$data{gosim} = $hash2{$key}->{gosim};
					$data{fraction} = $hash2{$key}->{fraction};
					$data{go_frac} = $hash2{$key}->{go_frac};
					$data{sf_frac} = $hash2{$key}->{sf_frac};
					$data{int_prob} = $hash2{$key}->{int};
					$data{struct_prob} = $hash2{$key}->{struct};
					$data{func_prob} = $hash2{$key}->{func};
					#printf "%s\n", join ", ", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
					$RESULT->insert( %data );
				}
				printf "%s\n", $seq;
			}
		}
	}
}
sub bddbResult_266 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	my $godatabase = 'mygo';
	my $sthId = $ddb_global{dbh}->prepare(sprintf "SELECT id,acc FROM %s.term WHERE term_type = 'molecular_function' AND is_obsolete = 0",$godatabase);
	$sthId->execute();
	my $sthGetC = $ddb_global{dbh}->prepare(sprintf "SELECT COUNT(DISTINCT term_id) AS n_terms,COUNT(DISTINCT gene_product_id) AS uni,COUNT(*) AS n FROM %s.graph_path g INNER JOIN %s.association ON term2_id = term_id WHERE term1_id = ?",$godatabase,$godatabase);
	while (my($id,$acc)=$sthId->fetchrow_array()) {
		$sthGetC->execute( $id );
		my %data;
		$data{goacc} = $acc;
		$data{term_id} = $id;
		($data{n_terms},$data{n_products},$data{n_associations}) = $sthGetC->fetchrow_array();
		printf "%s %s %s %s %s\n",values %data;
		$RESULT->insertignore(%data);
	}
}
sub bddbResult_267 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	require DDB::SEQUENCE;
	require DDB::TMP;
	my $seq_aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT go.sequence_key,term.acc,evidence_code,term.name FROM test.tmptab2 INNER JOIN bddb.go ON tmptab2.sequence_key = go.sequence_key INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON go.acc = term.acc WHERE term_type = 'molecular_function' AND evidence_code IN ('IDA') AND source = 'SGD200409' GROUP BY go.sequence_key");
	require DDB::GO;
	my $method = 'filter_func';
	for my $seqkey (@$seq_aryref) {
		my $c = $RESULT->get_data( where => { sequence_key => $seqkey, method => $method } );
		next unless $#$c < 0;
		printf "%s\n", $seqkey;
		my $SEQ = DDB::SEQUENCE->get_object( id => $seqkey );
		my $go_aryref = DDB::GO->get_ids( sequence_key => $SEQ->get_id(), source => 'SGD200409', term_type => 'molecular_function', evidence_code => 'IDA');
		for my $goid (@$go_aryref) {
			my $TRUE = DDB::GO->get_object( id => $goid );
			for my $tab_source (qw( localization process both )) {
					my($hash,$hash2,$color,$str) = DDB::TMP->go_merge( tab_source => $tab_source, true => $TRUE, seq => $SEQ, method => $method );
			}
		}
	}
}
sub bddbResult_273 {
	my(%param)=@_;
	my $RESULT = $param{result};
	$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
	$RESULT->querydo("CREATE TABLE #TABLE# (id int not null primary key auto_increment,sequence_key int not null, orf varchar(15) not null, gene varchar(15) not null,domain_nr int not null, detect_method varchar(20) not null, parent varchar(20) not null, confidence varchar(20) not null,length int not null, n_segments int not null,n_tm_helix int not null,unique(sequence_key,domain_nr))");
	require DDB::DOMAIN;
	require DDB::SEQUENCE::AC;
	require DDB::SEQUENCE;
	require DDB::PROGRAM::TMHMM;
	require DDB::PROTEIN;
	my $aryref = DDB::PROTEIN->get_ids( experiment_key => 1 );
	printf "%d sequences\n",$#$aryref+1;
	for my $id (@$aryref) {
		my $PROTEIN = DDB::PROTEIN->get_object( id => $id );
		my $SEQ = DDB::SEQUENCE->get_object( id => $PROTEIN->get_sequence_key() );
		my $TMHMM = DDB::PROGRAM::TMHMM->get_object( sequence_key => $SEQ->get_id() );
		my $tot_n_helix = $TMHMM->get_n_tmhelices();
		#next unless $tot_n_helix;
		#printf "%s helix\n", $tot_n_helix;
		my $ac_aryref = DDB::SEQUENCE::AC->get_ids( sequence_key => $PROTEIN->get_sequence_key(), db => 'mips_2001' );
		my $AC = DDB::SEQUENCE::AC->get_object( id => $ac_aryref->[0] );
		my $dom_aryref = DDB::DOMAIN->get_ids( domain_source => 'ginzu', sequence_key => $PROTEIN->get_sequence_key() );
		my $reg_helix = 0;
		for my $did (@$dom_aryref) {
			my $DOMAIN = DDB::DOMAIN->get_object( id => $did );
			my %data;
			$data{sequence_key} = $PROTEIN->get_sequence_key();
			$data{orf} = $AC->get_ac();
			$data{gene} = $AC->get_ac2();
			$data{domain_nr} = $DOMAIN->get_domain_nr();
			$data{detect_method} = $DOMAIN->get_domain_type();
			$data{parent} = $DOMAIN->get_parent_id();
			$data{confidence} = $DOMAIN->get_confidence();
			$data{length} = $DOMAIN->get_length();
			$data{n_segments} = $DOMAIN->get_n_regions();
			$data{n_tm_helix} = $DOMAIN->get_n_tm_helix();
			$reg_helix += $data{n_tm_helix};
			$RESULT->insertignore( %data );
		}
		warn sprintf "Inconsistent %d != %d for %s ...\n",$reg_helix,$tot_n_helix,$SEQ->get_id() unless $reg_helix == $tot_n_helix;
	}
}
sub bddbResult_275 {
	my(%param)=@_;
	my $RESULT = $param{result};
	$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
	$RESULT->querydo("CREATE TABLE #TABLE# (id int primary key not null auto_increment, sequence_key int not null,domain_key int not null, orf varchar(25) not null, domain_nr int not null, domain_type varchar(25) not null, span varchar(50) not null,length int not null, information text not null,unique(domain_key))");
	my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT domain.id FROM explorerProtein INNER JOIN protein ON protein_key = protein.id INNER JOIN domain ON sequence_key = parent_sequence_key WHERE explorer_key = 37 AND domain_source = 'ginzu' ORDER BY sequence_key,domain_nr");
	#my $aryref = [24619];
	require DDB::DOMAIN;
	require DDB::PAGE;
	require CGI;
	my $PAGE = DDB::PAGE->new( db => 'bddb', query => CGI->new() );
	$ENV{SCRIPT_NAME} = 'bddbx.cgi';
	$ENV{QUERY_STRING} = '';
	require DDB::SEQUENCE::AC;
	for my $id (@$aryref) {
		my $DOM = DDB::DOMAIN->get_object( id => $id );
		my $ac_aryref = DDB::SEQUENCE::AC->get_ids( sequence_key => $DOM->get_parent_sequence_key(), db => 'sgd' );
		my $AC = DDB::SEQUENCE::AC->get_object( id => $ac_aryref->[0] );
		my %data;
		$data{domain_key} = $DOM->get_id();
		$data{sequence_key} = $DOM->get_parent_sequence_key();
		$data{domain_nr} = $DOM->get_domain_nr();
		$data{domain_type} = $DOM->get_domain_type();
		$data{orf} = sprintf "%s/%s", $AC->get_ac2(),$AC->get_ac();
		$data{length} = $DOM->get_length();
		$data{span} = $DOM->get_span_string();
		$data{information} = $PAGE->_domainInfo( $DOM );
		$RESULT->insert( %data );
	}
}
sub bddbResult_276 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# ( `id` int(11) NOT NULL auto_increment, `measurement` varchar(255) NOT NULL default '', `value` double NOT NULL default '0', str_value varchar(255) NOT NULL default '', `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `measurement` (`measurement`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 ");
	}
	if (1==1) {
		my $exp = '1';
		$RESULT->insert( measurement => 'Experiment', str_value => $exp );
		$RESULT->insert( measurement => "N sequences", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = sequence_key WHERE experiment_key IN ($exp) AND domain_source = 'ginzu'") } );
		# warning - ginzu-domains are not guaranteed to have a domain_sequence_key and hence, this is an underestimation
		$RESULT->insert( measurement => "N single domain sequences", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = sequence_key WHERE experiment_key IN ($exp) AND domain_source = 'ginzu' AND domain_sequence_key = parent_sequence_key AND domain_type not In ('psiblast','fold_recognition')") } );
		$RESULT->insert( measurement => "N single domain sequences folded", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key WHERE experiment_key IN ($exp) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key") } );
		$RESULT->insert( measurement => "N single domain sequences folded with molecular function", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key INNER JOIN go ON parent_sequence_key = go.sequence_key INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON go.acc = term.acc WHERE experiment_key IN ($exp) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key AND go.source = 'sgd200409' AND term.term_type = 'molecular_function' AND evidence_code IN ('IDA','TAS','IC','IMP','IGI','IPI')") } );
		$RESULT->insert( measurement => "N single domain sequences localized", value => do{ $ddb_global{dbh}->selectrow_array("SELECT COUNT(DISTINCT domain.parent_sequence_key) FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN bddbResult.oshea of ON domain_sequence_key = of.sequence_key WHERE experiment_key IN ($exp) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key") } );
		$ddb_global{dbh}->do("DROP TABLE IF EXISTS test.seqre");
		$ddb_global{dbh}->do("CREATE TABLE test.seqre (id int not null primary key auto_increment, sequence_key int not null,foldable int not null, oshea int not null, gavin int not null, krogan int not null,sgd_function int not null,UNIQUE KEY sequence_key (sequence_key))");
		$ddb_global{dbh}->do("INSERT IGNORE test.seqre (sequence_key) SELECT sequence_key FROM bddbResult.oshea WHERE is_localized = 1");
		$ddb_global{dbh}->do("UPDATE test.seqre INNER JOIN bddbResult.oshea ON seqre.sequence_key = oshea.sequence_key SET oshea = 1 WHERE is_localized = 1");
		$ddb_global{dbh}->do("INSERT IGNORE test.seqre (sequence_key) SELECT sequence_key FROM bddbResult.gavin_complexes WHERE have_process = 1");
		$ddb_global{dbh}->do("UPDATE test.seqre INNER JOIN bddbResult.gavin_complexes ON seqre.sequence_key = gavin_complexes.sequence_key SET gavin = 1 WHERE have_process = 1");
		$ddb_global{dbh}->do("INSERT IGNORE test.seqre (sequence_key) SELECT sequence_key FROM bddbResult.krogan_complexes WHERE have_process = 1");
		$ddb_global{dbh}->do("UPDATE test.seqre INNER JOIN bddbResult.krogan_complexes ON seqre.sequence_key = krogan_complexes.sequence_key SET krogan = 1 WHERE have_process = 1");
		$ddb_global{dbh}->do("INSERT IGNORE test.seqre (sequence_key) SELECT domain.parent_sequence_key FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key WHERE experiment_key IN (1) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key");
		$ddb_global{dbh}->do("UPDATE test.seqre INNER JOIN bddb.domain ON seqre.sequence_key = parent_sequence_key INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key SET foldable = 1 WHERE experiment_key IN (1) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key");
		$ddb_global{dbh}->do("INSERT IGNORE test.seqre (sequence_key) SELECT domain.parent_sequence_key FROM bddb.domain INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key INNER JOIN go ON parent_sequence_key = go.sequence_key INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON go.acc = term.acc WHERE experiment_key IN (1) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key AND go.source = 'sgd200409' AND term.term_type = 'molecular_function' AND evidence_code IN ('IDA','TAS','IC','IMP','IGI','IPI')");
		$ddb_global{dbh}->do( "UPDATE test.seqre INNER JOIN bddb.domain ON seqre.sequence_key = parent_sequence_key INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key SET foldable = 1 WHERE experiment_key IN (1) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key");
		$ddb_global{dbh}->do("UPDATE test.seqre INNER JOIN bddb.domain ON seqre.sequence_key = parent_sequence_key INNER JOIN bddb.protein ON parent_sequence_key = protein.sequence_key INNER JOIN mcmData of ON domain_sequence_key = of.sequence_key INNER JOIN go ON parent_sequence_key = go.sequence_key INNER JOIN $DDB::DATABASE::MYGO::obj_table_term ON go.acc = term.acc SET sgd_function = 1 WHERE experiment_key IN (1) AND domain_source = 'foldable' AND domain_sequence_key = parent_sequence_key AND go.source = 'sgd200409' AND term.term_type = 'molecular_function' AND evidence_code IN ('IDA','TAS','IC','IMP','IGI','IPI')");
	}
}
sub bddbResult_279 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# ( `id` int(11) NOT NULL auto_increment, `complex` varchar(50) NOT NULL default '', `sequence_key` int NOT NULL default '0', orf varchar(15) NOT NULL default '', `gene` varchar(15) NOT NULL default '',have_process INT not null,`timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP, PRIMARY KEY (`id`),UNIQUE KEY compl (complex,sequence_key)) ENGINE=MyISAM DEFAULT CHARSET=latin1 ");
		open IN, "<suppl2.csv";
		my @lines = <IN>;
		close IN;
		chomp @lines;
		require DDB::SEQUENCE::AC;
		shift @lines;
		for my $line (@lines) {
			my @parts = split /\t/, $line;
			confess "Wrong number of columns\n" unless $#parts == 5;
			my $name = sprintf "%d: %s", $parts[0],$parts[1];
			my @members = split /\s+/, $parts[2];
			printf "%s %s members\n",$name, $#members+1;
			next unless $#members > 0;
			for my $member (@members) {
				my $aryref = DDB::SEQUENCE::AC->get_ids( ac2 => $member );
				$aryref = DDB::SEQUENCE::AC->get_ids( ac => $member, db => 'SGD' ) if $#$aryref < 0;
				if ($#$aryref == 0) {
					my $AC = DDB::SEQUENCE::AC->get_object( id => $aryref->[0] );
					$RESULT->insertignore( complex => $name, sequence_key => $AC->get_sequence_key(), orf => $AC->get_ac(), gene => $AC->get_ac2() );
				} else {
					warn sprintf "Not expected: %d %s\n", $#$aryref+1,$member;
				}
			}
		}
	}
	$RESULT->querydo("UPDATE #TABLE# t INNER JOIN bddb.go ON t.sequence_key = go.sequence_key SET have_process = 1 WHERE source = 'sgd200409' AND evidence_code IN ('IDA','IPI','IMP','TAS','IGI','ISS','IC')");
}
sub bddbResult_280 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# ( `id` int(11) NOT NULL auto_increment, `complex` varchar(50) NOT NULL default '', `sequence_key` int NOT NULL default '0', orf varchar(15) NOT NULL default '', `gene` varchar(15) NOT NULL default '',have_process int not null default 0,`timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP, PRIMARY KEY (`id`),UNIQUE KEY compl (complex,sequence_key)) ENGINE=MyISAM DEFAULT CHARSET=latin1 ");
		open IN, "<MCL_clusters.txt";
		my @lines = <IN>;
		close IN;
		chomp @lines;
		require DDB::SEQUENCE::AC;
		shift @lines;
		for my $line (@lines) {
			my @parts = split /\t/, $line;
			my $name = sprintf "%d: %s", shift @parts,shift @parts;
			my @members = @parts;
			printf "%s %s members\n",$name, $#members+1;
			next unless $#members > 0;
			for my $member (@members) {
				next unless $member;
				my $aryref = DDB::SEQUENCE::AC->get_ids( ac2 => $member );
				$aryref = DDB::SEQUENCE::AC->get_ids( ac => $member, db => 'SGD' ) if $#$aryref < 0;
				if ($#$aryref == 0) {
					my $AC = DDB::SEQUENCE::AC->get_object( id => $aryref->[0] );
					$RESULT->insertignore( complex => $name, sequence_key => $AC->get_sequence_key(), orf => $AC->get_ac(), gene => $AC->get_ac2() );
				} else {
					warn sprintf "Not expected: %d %s\n", $#$aryref+1,$member;
				}
			}
		}
	}
	$RESULT->querydo("UPDATE #TABLE# t INNER JOIN bddb.go ON t.sequence_key = go.sequence_key SET have_process = 1 WHERE source = 'sgd200409' AND evidence_code IN ('IDA','IPI','IMP','TAS','IGI','ISS','IC')");
}
sub bddbResult_285 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, result_key int not null, fkey int not null, frame int not null, offset int not null, ss_order char(10) not null, pairings char(15) not null)");
	}
	my $rid = 281;
	my $RFOR = DDB::RESULT->get_object( id => $rid );
	my $aryref = $RFOR->get_data( columns => ['id','ss_order','strand_pairing','cl'], limit => 1 );
	for my $row (@$aryref) {
		my($id,$sso,$pair,$cl) = @$row;
		printf "%s %s %s\n", $id,$sso,$pair;
		my @ary = split /[\s,]/, $pair;
		my $n = 5;
		for (my $i=0; $i<length($sso)-$n+1;$i++) {
			my $remap = '';
			for (my $j=0;$j<@ary;$j=$j+2) {
				next unless $ary[$j]-$i > 0;
				next unless $ary[$j+1]-$i > 0;
				next unless $ary[$j]-$i < $n+$i+1;
				next unless $ary[$j+1]-$i < $n+$i+1;
				$remap .= sprintf "%d,%d ",$ary[$j]-$i,$ary[$j+1]-$i;
			}
			my $nsso = substr($sso, $i,$n);
			my %data = ( offset => $i, frame => $n, fkey => $id, ss_order => $nsso, pairings => $remap );
			printf "%d:%d %s %s\n",$i,$n, $nsso,$remap;
			$RESULT->insert( %data );
		}
	}
}
sub bddbResult_286 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RES287 = DDB::RESULT->get_object( id => 287 );
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, protocol varchar(15) not null,cl varchar(255) not null, good int not null, total int not null, fraction double not null,decoy_key int not null, unique(protocol,cl), index(protocol) )");
		$RES287->querydo("DELETE FROM #TABLE#");
	}
	if (1==0) {
		my($good,$all)=$ddb_global{dbh}->selectrow_array("SELECT SUM(IF(mx6='yes',1,0)),COUNT(*) FROM bddbResult.scopFoldTopologies WHERE sequence_length != -1 GROUP BY tag");
		my %data = ( good => $good, total => $all, fraction => $good/$all, cl => 'all', protocol => 'all' );
		$RESULT->insert( %data );
	}
	if (1==0) {
		for my $cl (qw( doubl OBfold greek-key prot-L cross-beta beta_grasp ferredoxin SH3 2134 )) {
			my($good,$all)=$ddb_global{dbh}->selectrow_array("SELECT SUM(IF(mx6='yes',1,0)),COUNT(*) FROM bddbResult.scopFoldTopologies WHERE cl REGEXP '$cl' AND sequence_length != -1 GROUP BY tag");
			printf "%s %s %s\n", $good,$all,$cl;
			my %data = ( good => $good, total => $all, fraction => $good/$all, cl => $cl, protocol => 'phil' );
			$RESULT->insert( %data );
		}
	}
	if (1==0) {
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,COUNT(DISTINCT strand_pairing),COUNT(*) FROM bddbResult.astralTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 AND LENGTH(TRIM(ss_order)) > 3 GROUP BY ss_order,strand_pairing HAVING COUNT(*) > 1");
		$sth->execute();
		warn $sth->rows();
		while (my $hash = $sth->fetchrow_hashref) {
			printf "%s %s\n", $hash->{sso},$hash->{ssp};
			my($good,$all)=$ddb_global{dbh}->selectrow_array(sprintf "SELECT SUM(IF(mx6='yes',1,0)),COUNT(*) FROM bddbResult.scopFoldTopologies WHERE TRIM(ss_order) = '%s' AND TRIM(strand_pairing) = '%s' AND sequence_length != -1 GROUP BY tag",$hash->{sso},$hash->{ssp});
			printf "%s %s\n", $good,$all;
			next unless $all;
			my %data = ( good => $good, total => $all, fraction => $good/$all, cl => (sprintf "%s-%s",$hash->{sso},$hash->{ssp}), protocol => 'ident' );
			$RESULT->insert( %data );
		}
	}
	if (1==0) {
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,COUNT(DISTINCT strand_pairing),COUNT(*) FROM bddbResult.astralTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 AND LENGTH(TRIM(ss_order)) > 3 GROUP BY ss_order,strand_pairing HAVING COUNT(*) > 1");
		$sth->execute();
		warn $sth->rows();
		while (my $hash = $sth->fetchrow_hashref) {
			printf "%s %s\n", $hash->{sso},$hash->{ssp};
			my($good,$all)=$ddb_global{dbh}->selectrow_array(sprintf "SELECT SUM(IF(mx6='yes',1,0)),COUNT(*) FROM bddbResult.scopFoldTopologies WHERE TRIM(ss_order) LIKE '%%%s%%' AND TRIM(strand_pairing) LIKE '%%%s%%' AND sequence_length != -1 GROUP BY tag",$hash->{sso},$hash->{ssp});
			next unless $all;
			#printf "%s %s\n", $good,$all;
			my %data = ( good => $good, total => $all, fraction => $good/$all, cl => (sprintf "%s-%s",$hash->{sso},$hash->{ssp}), protocol => 'like' );
			$RESULT->insert( %data );
		}
	}
	if (1==1) {
		#my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,SUM(IF(mx6='yes',1,0)) AS good,COUNT(*) AS total,MAX(decoy_key) AS decoy_key FROM bddbResult.scopFoldTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 AND ss_order = 'EEEEEEEE' AND strand_pairing = '1,2 1,8 2,3 3,4 4,5 5,6 6,7 7,8' GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,SUM(IF(mx6='yes',1,0)) AS good,COUNT(*) AS total,MAX(decoy_key) AS decoy_key FROM bddbResult.scopFoldTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		$sth->execute();
		printf "Found %d rows\n", $sth->rows();
		my %motifg;
		my %motift;
		my %motifd;
		mot: while (my $hash = $sth->fetchrow_hashref) {
			#warn sprintf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
			my %subdata = ( ss_order => $hash->{sso}, strand_pairing => $hash->{ssp} );
			my $debug = sprintf "%s %s\n", $hash->{sso},$hash->{ssp};
			my %mapping;
			my $e_count = 0;
			for (my $k=0;$k<length $hash->{sso};$k++) {
				if (substr($hash->{sso},$k,1) eq 'E') {
					++$e_count;
					$mapping{$e_count} = $k+1;
				}
			}
			$debug .= sprintf "%s %s\n", $hash->{sso}, join ", ", map{ sprintf "%s => %s", $_, $mapping{$_} }sort{ $a <=> $b}keys %mapping;
			#len: for my $n (qw(5 )) {
			len: for my $n (qw(2 3 4 5 6 7 8)) {
				my @parts = split / /,$hash->{ssp};
				$subdata{tot_pairings} = $#parts+1;
				last len if $#parts < $n-1;
				#printf "N pairings: %d\n",$n;
				for (my $i=0;$i<@parts-$n+1;$i++) {
					my @tmp = @parts[$i..$i+$n-1];
					my $min = 99;
					my $max = 0;
					my @tmp2;
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						$min = $f if $f < $min;
						$min = $t if $t < $min;
						$max = $f if $f > $max;
						$max = $t if $t > $max;
					}
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						push @tmp2, sprintf "%d,%d",$f-$min+1,$t-$min+1;
					}
					confess "Not defined\n" unless defined $mapping{$min};
					confess "Not defined 2\n" unless defined $mapping{$max-$min+1};
					my $mot = substr($hash->{sso},$mapping{$min}-1,$mapping{$max-$min+1});
					my $motold = substr($hash->{sso},$min,$max-$min);
					#printf "New: %s\nOld: %s\n", $mot,$motold;
					my $pat = (join ":",@tmp2);
					#printf "%d-%d %s %s (%s)\n",$min,$max,$mot,$pat,(join ":",@tmp);
					$motifg{$mot.'-'.$pat} += $hash->{good};
					$motift{$mot.'-'.$pat} += $hash->{total};
					$motifd{$mot.'-'.$pat} = $hash->{decoy_key} || -1;
					$subdata{submotif} = $mot.'-'.$pat;
					$subdata{n_ss} = length $mot;
					$subdata{n_pairings} = $n;
					$RES287->insertignore( %subdata );
				}
			}
		}
		for my $motif (keys %motift) {
			#printf "%s %d %d\n",$motif,$motifg{$motif},$motift{$motif};
			my %data = ( good => $motifg{$motif}, total => $motift{$motif}, fraction => $motifg{$motif}/$motift{$motif}, cl => $motif, protocol => 'rel', decoy_key => $motifd{$motif} || confess "Wrong\n" );
			$RESULT->insertignore( %data );
		}
	}
}
sub bddbResult_287 {
	my(%param)=@_;
	confess "Use 286 - updates both...\n";
}
sub bddbResult_289 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::RESULT;
	my $RES288 = DDB::RESULT->get_object( id => 288 );
	if (1==1) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, protocol varchar(15) not null, gene_product_id int not null, term_id int not null,goacc varchar(15) not null, term_type varchar(25) not null)");
	}
	my $sthGo = $ddb_global{dbh}->prepare("SELECT DISTINCT term.id,term.term_type,term.acc FROM $DDB::DATABASE::MYGO::obj_table_term INNER JOIN $DDB::DATABASE::MYGO::obj_table_graph_path ON term1_id = term.id WHERE term2_id = ? AND term.is_obsolete = 0 AND term1_id IN (SELECT term_id FROM bddbResult.GOCut WHERE protocol = ?)");
	if (1==1) {
		for my $protocol (@{$RES288->get_data_column( column => 'protocol', uniq => 1) }) {
			my $cannot_find = 0;
			my %cannot;
			my $sthGP = $ddb_global{dbh}->prepare("SELECT term_id,gene_product_id FROM $DDB::DATABASE::MYGO::obj_table_assoc WHERE term_id NOT IN (6,8,2686,5012)");
			$sthGP->execute();
			while (my ($term_id,$gp_id) = $sthGP->fetchrow_array()) {
				$sthGo->execute( $term_id, $protocol );
				if ($sthGo->rows() == 0) {
					++$cannot_find;
					$cannot{$term_id} = 1;
					#} elsif ($sthGo->rows() > 1) {
					#confess sprintf "Too many: %d ($term_id,$protocol)...\n",$sthGo->rows();
				} else {
					my %data;
					while (($data{term_id},$data{term_type},$data{goacc}) = $sthGo->fetchrow_array()) {
						$data{gene_product_id} = $gp_id;
						$data{protocol} = $protocol;
						$RESULT->insert( %data );
					}
				}
			}
			printf "Cannot find %d for %s (%s)\n", $cannot_find,$protocol,join ", ",keys %cannot;
		}
	}
}
sub bddbResult_291 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RES292 = DDB::RESULT->get_object( id => 292 );
	if (1==0) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, protocol varchar(15) not null,cl varchar(255) not null, good int not null, total int not null, fraction double not null,decoy_key int not null, unique(protocol,cl), index(protocol) )");
		$RES292->querydo("DELETE FROM #TABLE#");
	}
	if (1==1) {
		#my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,SUM(IF(mx6='yes',1,0)) AS good,COUNT(*) AS total,MAX(decoy_key) AS decoy_key FROM bddbResult.scopFoldTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 AND ss_order = 'EEEEEEEE' AND strand_pairing = '1,2 1,8 2,3 3,4 4,5 5,6 6,7 7,8' GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,SUM(IF(mx6='yes',1,0)) AS good,COUNT(*) AS total,MAX(decoy_key) AS decoy_key FROM bddbResult.casp7Topologies WHERE LENGTH(TRIM(strand_pairing)) > 3 GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		$sth->execute();
		printf "Found %d rows\n", $sth->rows();
		my %motifg;
		my %motift;
		my %motifd;
		mot: while (my $hash = $sth->fetchrow_hashref) {
			#warn sprintf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
			my %subdata = ( ss_order => $hash->{sso}, strand_pairing => $hash->{ssp} );
			my $debug = sprintf "%s %s\n", $hash->{sso},$hash->{ssp};
			my %mapping;
			my $e_count = 0;
			for (my $k=0;$k<length $hash->{sso};$k++) {
				if (substr($hash->{sso},$k,1) eq 'E') {
					++$e_count;
					$mapping{$e_count} = $k+1;
				}
			}
			$debug .= sprintf "%s %s\n", $hash->{sso}, join ", ", map{ sprintf "%s => %s", $_, $mapping{$_} }sort{ $a <=> $b}keys %mapping;
			#len: for my $n (qw(5 )) {
			len: for my $n (qw(2 3 4 5 6 7 8)) {
				my @parts = split / /,$hash->{ssp};
				$subdata{tot_pairings} = $#parts+1;
				last len if $#parts < $n-1;
				#printf "N pairings: %d\n",$n;
				for (my $i=0;$i<@parts-$n+1;$i++) {
					my @tmp = @parts[$i..$i+$n-1];
					my $min = 99;
					my $max = 0;
					my @tmp2;
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						$min = $f if $f < $min;
						$min = $t if $t < $min;
						$max = $f if $f > $max;
						$max = $t if $t > $max;
					}
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						push @tmp2, sprintf "%d,%d",$f-$min+1,$t-$min+1;
					}
					confess "Not defined\n" unless defined $mapping{$min};
					confess "Not defined 2\n" unless defined $mapping{$max-$min+1};
					my $mot = substr($hash->{sso},$mapping{$min}-1,$mapping{$max-$min+1});
					my $motold = substr($hash->{sso},$min,$max-$min);
					#printf "New: %s\nOld: %s\n", $mot,$motold;
					my $pat = (join ":",@tmp2);
					#printf "%d-%d %s %s (%s)\n",$min,$max,$mot,$pat,(join ":",@tmp);
					$motifg{$mot.'-'.$pat} += $hash->{good};
					$motift{$mot.'-'.$pat} += $hash->{total};
					$motifd{$mot.'-'.$pat} = $hash->{decoy_key} || -1;
					$subdata{submotif} = $mot.'-'.$pat;
					$subdata{n_ss} = length $mot;
					$subdata{n_pairings} = $n;
					$RES292->insertignore( %subdata );
				}
			}
		}
		for my $motif (keys %motift) {
			#printf "%s %d %d\n",$motif,$motifg{$motif},$motift{$motif};
			my %data = ( good => $motifg{$motif}, total => $motift{$motif}, fraction => $motifg{$motif}/$motift{$motif}, cl => $motif, protocol => 'rel', decoy_key => $motifd{$motif} || confess "Wrong\n" );
			$RESULT->insertignore( %data );
		}
	}
}
sub bddbResult_292 {
	confess "is updated with 291\n";
}
sub bddbResult_293 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RES294 = DDB::RESULT->get_object( id => 294 );
	if (1==0) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, protocol varchar(15) not null,cl varchar(255) not null, good int not null, total int not null, fraction double not null,decoy_key int not null, unique(protocol,cl), index(protocol) )");
		$RES294->querydo("DELETE FROM #TABLE#");
	}
	if (1==1) {
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,0 AS good,COUNT(*) AS total,-1 AS decoy_key FROM bddbResult.astralTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		$sth->execute();
		printf "Found %d rows\n", $sth->rows();
		my %motifg;
		my %motift;
		my %motifd;
		mot: while (my $hash = $sth->fetchrow_hashref) {
			#warn sprintf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
			my %subdata = ( ss_order => $hash->{sso}, strand_pairing => $hash->{ssp} );
			my $debug = sprintf "%s %s\n", $hash->{sso},$hash->{ssp};
			my %mapping;
			my $e_count = 0;
			for (my $k=0;$k<length $hash->{sso};$k++) {
				if (substr($hash->{sso},$k,1) eq 'E') {
					++$e_count;
					$mapping{$e_count} = $k+1;
				}
			}
			$debug .= sprintf "%s %s\n", $hash->{sso}, join ", ", map{ sprintf "%s => %s", $_, $mapping{$_} }sort{ $a <=> $b}keys %mapping;
			#len: for my $n (qw(5 )) {
			len: for my $n (qw(2 3 4 5 6 7 8)) {
				my @parts = split / /,$hash->{ssp};
				$subdata{tot_pairings} = $#parts+1;
				last len if $#parts < $n-1;
				#printf "N pairings: %d\n",$n;
				for (my $i=0;$i<@parts-$n+1;$i++) {
					my @tmp = @parts[$i..$i+$n-1];
					my $min = 99;
					my $max = 0;
					my @tmp2;
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						$min = $f if $f < $min;
						$min = $t if $t < $min;
						$max = $f if $f > $max;
						$max = $t if $t > $max;
					}
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						push @tmp2, sprintf "%d,%d",$f-$min+1,$t-$min+1;
					}
					confess "Not defined\n" unless defined $mapping{$min};
					confess "Not defined 2\n" unless defined $mapping{$max-$min+1};
					my $mot = substr($hash->{sso},$mapping{$min}-1,$mapping{$max-$min+1});
					my $motold = substr($hash->{sso},$min,$max-$min);
					#printf "New: %s\nOld: %s\n", $mot,$motold;
					my $pat = (join ":",@tmp2);
					#printf "%d-%d %s %s (%s)\n",$min,$max,$mot,$pat,(join ":",@tmp);
					$motifg{$mot.'-'.$pat} += $hash->{good};
					$motift{$mot.'-'.$pat} += $hash->{total};
					$motifd{$mot.'-'.$pat} = $hash->{decoy_key} || -1;
					$subdata{submotif} = $mot.'-'.$pat;
					$subdata{n_ss} = length $mot;
					$subdata{n_pairings} = $n;
					$RES294->insertignore( %subdata );
				}
			}
		}
		for my $motif (keys %motift) {
			my %data = ( good => $motifg{$motif}, total => $motift{$motif}, fraction => $motifg{$motif}/$motift{$motif}, cl => $motif, protocol => 'rel', decoy_key => $motifd{$motif} || confess "Wrong\n" );
			$RESULT->insertignore( %data );
		}
	}
}
sub bddbResult_295 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RESULT205 = DDB::RESULT->get_object( id => 205 );
	my $RESULT251 = DDB::RESULT->get_object( id => 251 );
	my $seq_aryref = $RESULT205->get_data_column( column => 'domain_sequence_key' );
	require DDB::SEQUENCE;
	require DDB::PROGRAM::MAMMOTH;
	require DDB::STRUCTURE;
	require DDB::PROGRAM::MCM::DECOY;
	require DDB::PROGRAM::MCM::DATA;
	for my $sequence_key (@$seq_aryref) {
		next if $sequence_key == 15206; # Wrong number of rows...
		next if $sequence_key == 16535; # Wrong number of rows...
		next if $sequence_key == 18514; # Wrong number of rows...
		next if $sequence_key == 19327; # Wrong number of rows...
		next if $sequence_key == 19434; # Wrong number of rows...
		next if $sequence_key == 19617; # Wrong number of rows...
		next if $sequence_key == 20056; # Wrong number of rows...
		next if $sequence_key == 23008; # Wrong number of rows...
		next if $sequence_key == 23268; # Wrong number of rows...
		my $SEQ = DDB::SEQUENCE->get_object( id => $sequence_key );
		my $hash = $RESULT251->get_data_row( sequence_key => $SEQ->get_id() );
		unless ($hash->{fl_structure_key}) {
			printf "No full length structure for %s\n", $SEQ->get_id();
			next;
		}
		my @structures;
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{fl_structure_key} );
		push @structures, DDB::STRUCTURE->get_object( id => $hash->{m_structure_key} );
		for my $STRUCT (@structures) {
			printf "Working with domain sequence key: %d structure_key %d ", $sequence_key,$STRUCT->get_id();
			my $in_db = $ddb_global{dbh}->selectrow_array(sprintf "SELECT COUNT(*) FROM %s.%s WHERE sequence_key = %d AND structure_key = %d",$RESULT->get_resultdb(),$RESULT->get_table_name(),$sequence_key,$STRUCT->get_id());
			if ($in_db) {
				if (1==0) {
					printf "Exists, still continue...\n";
				} else {
					printf "Exists, go to next...\n";
					next;
				}
			}
			print "\n";
			my $solved_info = $hash->{solved_info} || confess "No information\n";
			# get all data decoys associated with this sequence
			my $mcmdecoy_aryref = DDB::PROGRAM::MCM::DECOY->get_ids( sequence_key => $SEQ->get_id() );
			confess sprintf "Want 10 decoys; found %d\n",$#$mcmdecoy_aryref+1 unless $#$mcmdecoy_aryref > 9;
			my $highmammoth = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			my $nfail2 = 0;
			my $npass2 = 0;
			my %match_mcm;
			for my $id (@$mcmdecoy_aryref) {
				my $MAMMOTH = DDB::PROGRAM::MAMMOTH->new( e_structure_object => $STRUCT, mcmdecoy_key => $id );
				eval {
					$MAMMOTH->run();
				};
				if ($@) {
					warn $@;
					$nfail2++;
				} else {
					$npass2++;
				}
				$match_mcm{ $id } = $MAMMOTH;
				# store the best match between a native and a decoy In highmammoth
				$highmammoth = $MAMMOTH if $MAMMOTH->get_zscore() > $highmammoth->get_zscore();
			}
			confess "None passed\n" if $npass2 == 0;
			my $mcmdata_aryref = DDB::PROGRAM::MCM::DATA->get_ids( sequence_key => $SEQ->get_id() );
			my @mcmdata;
			my $high1 = DDB::PROGRAM::MCM::DATA->new( tier_probability => -1 );
			my $high2;
			my $high3 = DDB::PROGRAM::MCM::DATA->new( tier_probability => -1 );
			my %match;
			my $nfailed = 0;
			for my $id (@$mcmdata_aryref) {
				my $DATA = DDB::PROGRAM::MCM::DATA->get_object( id => $id );
				#confess $DATA->get_tier_probability();
				my $pid = $DATA->get_experiment_file();
				$pid =~ s/\.pdb//;
				my $MAMMOTH = DDB::PROGRAM::MAMMOTH->new( e_structure_object => $STRUCT, p_structure_key => $pid );
				eval {
					$MAMMOTH->run();
					$match{ $DATA->get_id() } = $MAMMOTH;
					$high2 = $DATA unless $high2;
					$high2 = $DATA if $MAMMOTH->get_zscore() > $match{ $high2->get_id() }->get_zscore();
				};
				if (1==0 && $@) {
					confess $@;
				}
				$nfailed++ if $@;
				$high1 = $DATA if $DATA->get_tier_probability() > $high1->get_tier_probability();
				push @mcmdata, $DATA;
			}
			my $DECOY = DDB::PROGRAM::MCM::DECOY->get_object( id => $highmammoth->get_mcmdecoy_key() );
			for my $DATA (@mcmdata) {
				if ($DATA->get_mcm_decoy_key() == $DECOY->get_id()) {
					$high3 = $DATA if $DATA->get_tier_probability() > $high3->get_tier_probability();
				}
			}
			printf "%d '%s' '%s' '%s' '%s'\n", $#mcmdata+1,ref $highmammoth, ref $high1, ref $high2, ref $high3;
			unless ($match{ $high1->get_id() }) {
				warn sprintf "NOGOOD (high1): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high1->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			unless ($match{ $high2->get_id() }) {
				warn sprintf "NOGOOD (high2): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high2->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			unless ($match{ $high3->get_id() }) {
				warn sprintf "NOGOOD (high3): %d %d\n", $#mcmdata,$nfailed;
				$match{ $high3->get_id() } = DDB::PROGRAM::MAMMOTH->new( zscore => -999 );
			}
			my %data;
			$data{sequence_key} = $sequence_key;
			$data{structure_key} = $STRUCT->get_id();
			$data{solved_info} = $solved_info;
			$data{n_mcm_data} = $#mcmdata+1;
			$data{n_mcm_failed} = $nfailed;
			# highest mammoth match
			$data{mh_mcmDecoy_key} = $DECOY->get_id();
			$data{mh_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $DECOY->get_id(),$STRUCT->get_id();
			$data{mh_zscore} = $highmammoth->get_zscore();
			# highest tier_probability
			$data{prob_mcmData_key} = $high1->get_id();
			$data{prob_prob} = $high1->get_tier_probability();
			#$data{prob_prob} = $high1->get_tier_probability();
			$data{prob_mcmDecoy_key} = $high1->get_mcm_decoy_key();
			$data{prob_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high1->get_mcm_decoy_key(),$STRUCT->get_id();
			$data{prob_zscore} = $match_mcm{ $high1->get_mcm_decoy_key() }->get_zscore();
			#$data{prob_zscore} = $match{ $high1->get_id() }->get_zscore();
			$data{n2m_mcmData_key} = $high2->get_id();
			$data{n2m_prob} = $high2->get_tier_probability();
			#$data{n2m_prob} = $high2->get_tier_probability();
			$data{n2m_mcmDecoy_key} = $high2->get_mcm_decoy_key();
			$data{n2m_mammoth} = sprintf "structure_key:%d-structure_key:%d", $match{ $high2->get_id() }->get_p_structure_key(),$STRUCT->get_id();
			#$data{n2m_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high2->get_mcm_decoy_key(),$STRUCT->get_id();
			$data{n2m_zscore} = $match{ $high2->get_id() }->get_zscore();
			$data{n2decoy_mcmData_key} = $high3->get_id();
			$data{n2decoy_prob} = $high3->get_tier_probability();
			#$data{n2decoy_prob} = $high3->get_tier_probability();
			$data{n2decoy_mcmDecoy_key} = $high3->get_mcm_decoy_key();
			$data{n2decoy_zscore} = $match{ $high3->get_id() }->get_zscore();
			$data{n2decoy_mammoth} = sprintf "mcmdecoy_key:%d-structure_key:%d", $high3->get_mcm_decoy_key(),$STRUCT->get_id();
			$RESULT->insertreplace( %data );
		}
	}
	$RESULT->querydo(sprintf "UPDATE #TABLE# SET full_length = ''");
	$RESULT->querydo(sprintf "UPDATE #TABLE# t INNER JOIN #TABLE251# ON t.structure_key = fl_structure_key SET full_length = 'yes'");
	$RESULT->querydo(sprintf "UPDATE #TABLE# t INNER JOIN #TABLE251# ON t.structure_key = m_structure_key SET full_length = 'no'");
}
sub bddbResult_297 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RES298 = DDB::RESULT->get_object( id => 298 );
	if (1==0) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, protocol varchar(15) not null,cl varchar(255) not null, good int not null, total int not null, fraction double not null,decoy_key int not null, unique(protocol,cl), index(protocol) )");
		$RES298->querydo("DELETE FROM #TABLE#");
	}
	if (1==1) {
		my $sth = $ddb_global{dbh}->prepare("SELECT TRIM(ss_order) AS sso,TRIM(strand_pairing) AS ssp,0 AS good,COUNT(*) AS total,-1 AS decoy_key FROM bddbResult.pdbTopologies WHERE LENGTH(TRIM(strand_pairing)) > 3 GROUP BY TRIM(ss_order),TRIM(strand_pairing)");
		$sth->execute();
		printf "Found %d rows\n", $sth->rows();
		my %motifg;
		my %motift;
		my %motifd;
		mot: while (my $hash = $sth->fetchrow_hashref) {
			#warn sprintf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
			my %subdata = ( ss_order => $hash->{sso}, strand_pairing => $hash->{ssp} );
			my $debug = sprintf "%s %s\n", $hash->{sso},$hash->{ssp};
			my %mapping;
			my $e_count = 0;
			for (my $k=0;$k<length $hash->{sso};$k++) {
				if (substr($hash->{sso},$k,1) eq 'E') {
					++$e_count;
					$mapping{$e_count} = $k+1;
				}
			}
			$debug .= sprintf "%s %s\n", $hash->{sso}, join ", ", map{ sprintf "%s => %s", $_, $mapping{$_} }sort{ $a <=> $b}keys %mapping;
			#len: for my $n (qw(5 )) {
			len: for my $n (qw(2 3 4 5 6 7 8)) {
				my @parts = split / /,$hash->{ssp};
				$subdata{tot_pairings} = $#parts+1;
				last len if $#parts < $n-1;
				#printf "N pairings: %d\n",$n;
				for (my $i=0;$i<@parts-$n+1;$i++) {
					my @tmp = @parts[$i..$i+$n-1];
					my $min = 99;
					my $max = 0;
					my @tmp2;
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						$min = $f if $f < $min;
						$min = $t if $t < $min;
						$max = $f if $f > $max;
						$max = $t if $t > $max;
					}
					for (@tmp) {
						my($f,$t) = split /\,/,$_;
						confess "No '$_'\n$debug\n" unless $f && $t;
						push @tmp2, sprintf "%d,%d",$f-$min+1,$t-$min+1;
					}
					confess "Not defined\n" unless defined $mapping{$min};
					confess "Not defined 2\n" unless defined $mapping{$max-$min+1};
					my $mot = substr($hash->{sso},$mapping{$min}-1,$mapping{$max-$min+1});
					my $motold = substr($hash->{sso},$min,$max-$min);
					#printf "New: %s\nOld: %s\n", $mot,$motold;
					my $pat = (join ":",@tmp2);
					#printf "%d-%d %s %s (%s)\n",$min,$max,$mot,$pat,(join ":",@tmp);
					$motifg{$mot.'-'.$pat} += $hash->{good};
					$motift{$mot.'-'.$pat} += $hash->{total};
					$motifd{$mot.'-'.$pat} = $hash->{decoy_key} || -1;
					$subdata{submotif} = $mot.'-'.$pat;
					$subdata{n_ss} = length $mot;
					$subdata{n_pairings} = $n;
					$RES298->insertignore( %subdata );
				}
			}
		}
		for my $motif (keys %motift) {
			my %data = ( good => $motifg{$motif}, total => $motift{$motif}, fraction => $motifg{$motif}/$motift{$motif}, cl => $motif, protocol => 'rel', decoy_key => $motifd{$motif} || confess "Wrong\n" );
			$RESULT->insertignore( %data );
		}
	}
}
sub bddbResult_300 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $RES299 = DDB::RESULT->get_object( id => 299 );
	my $seqkey_aryref = $RES299->get_data_column( column => 'sequence_key',uniq => 1, where => { tag => 1 } );
	#printf "N_sequences: %d\n", $#$seqkey_aryref+1;
	for my $seqkey (@$seqkey_aryref) {
		my %data;
		my $hash = $ddb_global{dbh}->selectrow_hashref(sprintf "SELECT sequence_key,MIN(evalue) AS min_eval,GROUP_CONCAT(DISTINCT sccs) AS sf,sequence_length,astral_length,alignment_length FROM %s.%s WHERE tag = 1 AND sequence_key = %d GROUP BY sequence_key",$RES299->get_resultdb(),$RES299->get_table_name(),$seqkey);
		map{ $data{$_} = $hash->{$_}; sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
		#printf "%s\n", join "\n", map{ $data{$_} = $hash->{$_}; sprintf "%s => %s", $_, $hash->{$_} }keys %$hash;
		if (1==1) {
			my $sthProb = $ddb_global{dbh}->prepare("SELECT sequence_key,SUBSTRING_INDEX(experiment_sccs,'.',3) AS sf,MAX(probability) AS max_probability FROM bddb.mcmData WHERE sequence_key = ? AND probability > 0 GROUP BY sequence_key,SUBSTRING_INDEX(experiment_sccs,'.',3) ORDER BY probability DESC");
			$sthProb->execute( $seqkey );
			my $count = 0;
			while (my @row = $sthProb->fetchrow_array()) {
				$count++;
				if ($count == 1) {
					$data{high_probability_sccs} = $row[1];
					$data{high_probability} = $row[2];
				}
				if ($hash->{sf} =~ /^$row[1]\./) {
					$data{correct_rank} = $count;
					$data{correct_probability} = $row[2];
				}
			}
		}
		if (1==1) {
			my $sthTier = $ddb_global{dbh}->prepare("SELECT sequence_key,SUBSTRING_INDEX(experiment_sccs,'.',3) AS sf,MAX(tier_probability) AS max_probability FROM bddb.mcmData WHERE sequence_key = ? AND tier_probability > 0 GROUP BY sequence_key,SUBSTRING_INDEX(experiment_sccs,'.',3) ORDER BY tier_probability DESC");
			$sthTier->execute( $seqkey );
			my $count = 0;
			while (my @row = $sthTier->fetchrow_array()) {
				$count++;
				if ($count == 1) {
					$data{high_tier_probability_sccs} = $row[1];
					$data{high_tier_probability} = $row[2];
				}
				if ($hash->{sf} =~ /^$row[1]\./) {
					$data{correct_tier_rank} = $count;
					$data{correct_tier_probability} = $row[2];
				}
			}
		}
		if (1==1) {
			my $sthInt = $ddb_global{dbh}->prepare("SELECT sequence_key,SUBSTRING_INDEX(sccs,'.',3) AS sf,MAX(integrated_norm_probability) AS max_probability FROM bddb.mcmIntegration WHERE sequence_key = ? AND integrated_norm_probability > 0 GROUP BY sequence_key,SUBSTRING_INDEX(sccs,'.',3) ORDER BY integrated_norm_probability DESC");
			$sthInt->execute( $seqkey );
			my $count = 0;
			while (my @row = $sthInt->fetchrow_array()) {
				$count++;
				if ($count == 1) {
					$data{high_int_probability_sccs} = $row[1];
					$data{high_int_probability} = $row[2];
				}
				if ($hash->{sf} =~ /^$row[1]\./) {
					$data{correct_int_rank} = $count;
					$data{correct_int_probability} = $row[2];
				}
			}
		}
		$RESULT->insertignore( %data );
		#printf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
	}
}
sub bddbResult_302 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $sth= $ddb_global{dbh}->prepare("SELECT topologyMotifs2.cl,ROUND(topologyMotifs2.fraction,2),topologyMotifs2.total FROM bddbResult.topologyMotifs2 INNER JOIN bddbResult.astralTopologyMotifs2 ON topologyMotifs2.cl = astralTopologyMotifs2.cl WHERE topologyMotifs2.fraction >= 0.5 AND topologyMotifs2.total >= 10 ORDER BY topologyMotifs2.fraction DESC");
		$sth->execute();
		my $sthT = $ddb_global{dbh}->prepare("SELECT SUBSTRING_INDEX(sccs,'.',3),COUNT(*) AS n_total,COUNT(DISTINCT map.strand_pairing,map.ss_order) AS n_full,COUNT(DISTINCT submotif) AS n_sub FROM bddbResult.astralTopologyMotifs2map map INNER JOIN bddbResult.astralTopologies astralTop ON map.strand_pairing = astralTop.strand_pairing AND map.ss_order = astralTop.ss_order WHERE submotif = ? GROUP BY SUBSTRING_INDEX(sccs,'.',3) WITH ROLLUP");
		#printf "submotif\tfraction_good_decoys\tn_total_decoys\tn_superfamily\tn_astral_domains_with_submotif\tsuperfamily_percent\n";
		while (my @row = $sth->fetchrow_array()) {
			$sthT->execute( $row[0] );
			my $data = $sthT->fetchall_arrayref();
			#printf "%s %d\n", ref $data,$#$data+1;
			my $n = 0;
			my $ori = pop @$data;
			my $str = '';
			for my $trow (sort{ $b->[1] <=> $a->[1] }@$data) {
				$str .= sprintf "%s:%.2f ",$trow->[0],$trow->[1]/$ori->[1];
				last if ++$n >= 3;
			}
			my %data = (fraction_good_decoys => $row[1], n_total_decoys => $row[2],n_superfamily => $sthT->rows()-1,n_astral_domains_with_submotif => $ori->[1], submotif => $row[0], superfamily_percent => $str );
			$RESULT->insertignore( %data );
			#printf "%s\n", join "\t", $row[1],$row[2],$sthT->rows()-1,$ori->[1],$row[0],$str;
		}
		#printf "%s\n", join "\n", @$aryref;
}
sub bddbResult_306 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $directory = sprintf "%s/mcm",get_tmpdir();
	my @files = glob("$directory/*/log.xml");
	printf "Found %d files\n", $#files+1;
	require DDB::PROGRAM::MCM;
	require DDB::SEQUENCE;
	require DDB::PROGRAM::MCM::DATA;
	for my $file (@files) {
		$RESULT->insertignore( filename => $file );
		my $bufseq = 0;
		my ($id,$seqkey,$tfile,$imported,$high,$sccs,$log) = @{ $RESULT->get_data_row_aryref( filename => $file ) };
		confess "Wrong\n" unless $tfile eq $file;
		$bufseq = $seqkey if $seqkey;
		if (1==1) {
			my $tmpseq = `grep "<sequence>" $file`;
			$tmpseq =~ s/^\s*\<sequence\>// || confess "Cannot remove first tag\n";
			$tmpseq =~ s/\<\/sequence\>\s*$// || confess "Cannot remove last tag\n";
			my $aryref = DDB::SEQUENCE->get_ids( sequence => $tmpseq );
			unless ($#$aryref == 0) {
				printf "%s\n%s\n",$tmpseq,$file;
				$aryref = DDB::SEQUENCE->get_ids( sequencelike => $tmpseq );
				$aryref = [32016] if $id == 107;
				if ($#$aryref == 0) {
					printf "Parent: %d (id: $id)\n", $aryref->[0];
					require DDB::DOMAIN;
					my $DOMAIN = DDB::DOMAIN->new();
					$DOMAIN->set_parent_sequence_key( $aryref->[0] );
					$DOMAIN->set_domain_nr( 1 );
					$DOMAIN->set_comment( 'casptrim' );
					my $start = 0;
					my $stop = 0;
					my $SEQ = DDB::SEQUENCE->get_object( id => $DOMAIN->get_parent_sequence_key() );
					subseq: for (my $i = 0; $i < length( $SEQ->get_sequence());$i++) {
						if (substr($SEQ->get_sequence(),$i,length($tmpseq)) eq $tmpseq) {
							$start = $i+1;
							$stop = $i+length($tmpseq);
							last subseq;
						}
					}
					$DOMAIN->add_region( start => $start, stop => $stop, segment => 'A' ); # only contiguous domains, hence segment A
					$DOMAIN->add();
				} elsif ($#$aryref < 0) {
					my $stem = (split /\//, $file)[-2];
					my $tmpfastafile = sprintf "%s/%s.fasta",get_tmpdir(), $stem;
					confess "Exists...\n" if -f $tmpfastafile;
					open OUT, ">$tmpfastafile";
					printf OUT ">%s %s\n%s\n", $stem,$stem,$tmpseq;
					close OUT;
					my $new_seqkey = DDB::SEQUENCE->import_from_fasta_file( file => $tmpfastafile, comment => 'casp7 user sequence import', experiment_key => 28 );
				} else {
					confess sprintf "More than one parent: %s (id: %d)\n%s\n",(join ", ", @$aryref),$id,$tmpseq;
				}
			}
		}
		next if $log;
		next if $seqkey != 0 && $imported eq 'yes';
		printf "%s %s %s %s\n", $id,$seqkey,$imported,$file;
		#bddb.pl -mode import -submode mcm -file log.xml
		eval {
			{
				local $/;
				undef $/;
				open IN, "<$file";
				my $content = <IN>;
				close IN;
				my $seq = DDB::PROGRAM::MCM->cache( xml => $content, logfile => $file, all => 1 );
				confess "No seq returned\n" unless $seq;
				$bufseq = $seq if $seq;
				my $aryref = DDB::PROGRAM::MCM::DATA->get_ids( sequence_key => $seq );
				confess "No data imported\n" unless $aryref->[0];
				my $DATA = DDB::PROGRAM::MCM::DATA->get_object( id => $aryref->[0] );
				printf "%s %s %s\n",$seq, $#$aryref+1,$DATA->get_probability();
				my $sccs = join ".", (split /\./, $DATA->get_experiment_sccs())[0..2];
				$RESULT->update( values => { sequence_key => $seq, imported => 'yes',high_confidence => $DATA->get_probability(), sccs => $sccs } , where => { id => $id } );
			}
		};
		if ($@) {
			my $log = sprintf "Failed (seq: %d) %s\n",$bufseq, (split /\n/, $@)[0] if $@;
			$RESULT->update( values => { log => $log } , where => { id => $id } );
			#exit;
		}
	}
}
sub bddbResult_336 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::DOMAIN;
	require DDB::PROTEIN;
	my $aryref = DDB::DOMAIN->get_ids( domain_source => 'user_defined', comment_like => 'SUPERFAM' );
	printf "%d domains to check\n", $#$aryref+1;
	for my $id (@$aryref) {
		my $UDOM = DDB::DOMAIN->get_object( id => $id );
		my $protein_aryref = DDB::DOMAIN->get_ids( sequence_key => $UDOM->get_parent_sequence_key(), experiment_key => 1 );
		if ($#$protein_aryref < 0) {
			warn "Not In MIPS\n";
		} else {
			my $ginzu_aryref = DDB::DOMAIN->get_ids( domain_source => 'ginzu', parent_sequence_key => $UDOM->get_parent_sequence_key() );
			#printf "%s %d ginzu domains\n", $UDOM->get_parent_sequence_key(),$#$ginzu_aryref+1;
			my $max = 0;
			my %data;
			$data{superfam_domain_key} = $UDOM->get_id();
			for my $ginzu_key (@$ginzu_aryref) {
				my $GDOM = DDB::DOMAIN->get_object( id => $ginzu_key );
				my $data = $UDOM->get_n_overlaping_aas( domain => $GDOM );
				next unless $data->{overlap};
				my $min_length = ($data->{own} < $data->{other}) ? $data->{own} : $data->{other};
				my $mol = $data->{overlap}/$min_length;
				#printf "%s %s %s\n", $min_length,$mol, join ", ", map{ sprintf "%s => %s", $_, $data->{$_} }keys %$data;
				if ($mol > $max) {
					$max = $mol;
					$data{superfam_length} = $data->{own};
					$data{ginzu_length} = $data->{other};
					$data{overlap} = $data->{overlap};
					$data{ginzu_domain_key} = $GDOM->get_id();
					$data{max_overlap} = $mol;
					$data{ginzu_domain_type} = $GDOM->get_domain_type();
				}
			}
			#printf "%s\n", join ", ", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
			$RESULT->insert( %data );
		}
	}
}
sub ddbResult_2 {
	#$RESULT->get_resultdb eq 'ddbResult' && $RESULT->get_id() == 2
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::EXPERIMENT;
	require DDB::LOCUS;
	for my $experiment_key (qw( 31 19 29 30)) {
		my $EXPERIMENT = DDB::EXPERIMENT->get_object( id => $experiment_key );
		my $aryref = DDB::LOCUS->get_ids( experiment_key => $EXPERIMENT->get_id() );
		printf "%d locus for %d\n", $#$aryref,$EXPERIMENT->get_id();
		for my $locus_key (@$aryref) {
			my $resultid = 0;
			my $LOCUS = DDB::LOCUS->get_object( id => $locus_key );
			# SSP x 4
			my $ssp = $LOCUS->get_locus_index();
			printf "%d\n", $ssp;
			$resultid = $ddb_global{dbh}->selectrow_array(sprintf "SELECT id FROM ddbResult.cervixSSP WHERE ssp%d = %d",$EXPERIMENT->get_id(),$ssp);
			my $sthInsertSSP = $ddb_global{dbh}->prepare(sprintf "INSERT ddbResult.cervixSSP (ssp%d) VALUES (?)",$EXPERIMENT->get_id());
			unless ($resultid) {
				if (ref($LOCUS) eq 'DDB::LOCUS::SUPERGEL') {
					$sthInsertSSP->execute( $ssp );
					$resultid = $sthInsertSSP->{mysql_insertid};
				} elsif (ref($LOCUS) eq 'DDB::LOCUS::GEL') {
					# FIND SUPER
					my $superssp = $LOCUS->get_super_ssp();
					my $tmp_resid = $ddb_global{dbh}->selectrow_array(sprintf "SELECT id FROM ddbResult.cervixSSP WHERE ssp31 = %d",$superssp);
					if ($tmp_resid) {
						my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE ddbResult.cervixSSP SET ssp%d = ? WHERE id = ?",$EXPERIMENT->get_id() );
						$sthUpdate->execute( $ssp, $tmp_resid );
						$resultid = $tmp_resid;
					} else {
						$sthInsertSSP->execute( $ssp );
						$resultid = $sthInsertSSP->{mysql_insertid};
					}
				} else {
					confess sprintf "Unknown: %d\n", ref($EXPERIMENT);
				}
			}
			confess "No resultid.....\n" unless $resultid;
			require DDB::GROUP;
			my $group_aryref = DDB::GROUP->get_ids( experiment_key => $EXPERIMENT->get_id() );
			printf "%d groups for %d\n",$#$group_aryref+1,$EXPERIMENT->get_id();
			my @group;
			for my $group_key (@$group_aryref) {
				my $GROUP = DDB::GROUP->get_object( id => $group_key );
				my $lcname = lc($GROUP->get_name());
				my $sthUpdateM = $ddb_global{dbh}->prepare(sprintf "UPDATE ddbResult.cervixSSP SET i_%s_%d = ?, sd_%s_%d = ?, c_%s_%d = ? WHERE id = ?",$lcname,$EXPERIMENT->get_id(),$lcname,$EXPERIMENT->get_id(),$lcname,$EXPERIMENT->get_id());
				printf "Working with %s %d\n", $lcname,$EXPERIMENT->get_id();
				$sthUpdateM->execute( $LOCUS->get_mean( group_key => $GROUP->get_id() ), $LOCUS->get_stddev( group_key => $GROUP->get_id() ) , $LOCUS->get_count( group_key => $GROUP->get_id() ), $resultid );
				push @group,$GROUP;
			}
			for (my $i = 0; $i < @group; $i++ ) {
				for (my $j = $i+1; $j < @group; $j++ ) {
					my $lc1 = lc($group[$i]->get_name());
					my $lc2 = lc($group[$j]->get_name());
					my $col;
					if ($lc1 eq 'np') {
						$col = sprintf "np_%s", $lc2;
					} elsif ($lc2 eq 'np') {
						$col = sprintf "np_%s", $lc1;
					} elsif ($lc1 eq 'pp') {
						$col = sprintf "pp_%s", $lc2;
					} elsif ($lc2 eq 'pp') {
						$col = sprintf "pp_%s", $lc1;
					} else {
						confess "Wrong\n";
					}
					my $sthUpdateP = $ddb_global{dbh}->prepare(sprintf "UPDATE ddbResult.cervixSSP SET p_%d_%s = ? WHERE id = ?",$EXPERIMENT->get_id(),$col);
					require Statistics::Distributions;
					$sthUpdateP->execute( $LOCUS->get_pvalue( group1_key => $group[$i]->get_id(), group2_key => $group[$j]->get_id() ) || 999,$resultid);
				}
			}
			# INSERT DATA - {NP,PP,TP} x {intensity,stddev,count} ttest - NP-PP NP-TP PP-TP
		}
	}
}
sub ddbResult_7 {
	#$RESULT->get_resultdb eq 'ddbResult' && $RESULT->get_id() == 7
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1 == 0) { # get gi from nucl accnr
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,GBAc FROM %s.%s WHERE GBAc != '' AND gi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		#my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,genbank FROM %s.%s WHERE genbank != '' AND gi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET gi = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$genbank) = $sthGet->fetchrow_array()) {
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=nucleotide&term=$genbank&retmax=10");
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			printf "%s %s %s\n", $id, $genbank, $xml->{IdList}->[0]->{Id}->[0];
			$sthUpdate->execute( $xml->{IdList}->[0]->{Id}->[0], $id );
			#last;
		}
	}
	if (1 == 0) { # transl gi to pgi
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,gi FROM %s.%s WHERE gi != 0 AND pgi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET pgi = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$gi) = $sthGet->fetchrow_array()) {
			#next if $gi == 976373;
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?retmode=text&retmax=10&db=Nucleotide&list_uids=$gi&dopt=xml");
			#printf "XML '%s'\n", $page;
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			my $pgi = $xml->{'Bioseq-set_seq-set'}->[0]->{'Seq-entry'}->[0]->{'Seq-entry_set'}->[0]->{'Bioseq-set'}->[0]->{'Bioseq-set_annot'}->[0]->{'Seq-annot'}->[0]->{'Seq-annot_data'}->[0]->{'Seq-annot_data_ftable'}->[0]->{'Seq-feat'}->[0]->{'Seq-feat_product'}->[0]->{'Seq-loc'}->[0]->{'Seq-loc_whole'}->[0]->{'Seq-id'}->[0]->{'Seq-id_gi'}->[0];
			printf "%s %s %s\n", $id, $gi, $pgi;
			$sthUpdate->execute( $pgi, $id );
			#last;
		}
	}
	if (1 == 1) { # guys with no pgi - get nucl.seq
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,gi FROM %s.%s WHERE gi != 0 AND pgi = 0 AND nucleotide_sequence IS NULL", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET nucleotide_sequence = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$gi) = $sthGet->fetchrow_array()) {
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?retmode=text&retmax=10&db=Nucleotide&list_uids=$gi&dopt=xml");
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			my $nucl = $xml->{'Bioseq-set_seq-set'}->[0]->{'Seq-entry'}->[0]->{'Seq-entry_seq'}->[0]->{'Bioseq'}->[0]->{'Bioseq_inst'}->[0]->{'Seq-inst'}->[0]->{'Seq-inst_seq-data'}->[0]->{'Seq-data'}->[0]->{'Seq-data_iupacna'}->[0]->{'IUPACna'}->[0]; #->[0]->{'Seq-loc'}->[0]->{'Seq-loc_whole'}->[0]->{'Seq-id'}->[0]->{'Seq-id_gi'}->[0];
			printf "ID: %s GI: %s; %s %s\n", $id, $gi, ref($nucl),$nucl;
			$sthUpdate->execute( $nucl, $id );
			#last;
		}
	}
}
sub ddbResult_9 {
	#$RESULT->get_resultdb eq 'ddbResult' && $RESULT->get_id() == 9
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1 == 0) { # get gi from nucl accnr
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,GBAccNo FROM %s.%s WHERE GBAccNo != '' AND gi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		#my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,genbank FROM %s.%s WHERE genbank != '' AND gi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET gi = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$genbank) = $sthGet->fetchrow_array()) {
			next if $genbank eq 'M03216';
			next if $genbank eq 'M975707';
			printf "%s %s\n", $id, $genbank;
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=nucleotide&term=$genbank&retmax=10");
			printf "XML '%s'\n", $page;
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			printf "%s\n", $xml->{IdList}->[0]->{Id}->[0];
			$sthUpdate->execute( $xml->{IdList}->[0]->{Id}->[0], $id );
			#last;
		}
	}
	if (1 == 0) { # transl gi to pgi
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,gi FROM %s.%s WHERE gi != 0 AND pgi = 0", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET pgi = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$gi) = $sthGet->fetchrow_array()) {
			next if $gi == 662761;
			next if $gi == 976373;
			printf "%s %s\n", $id, $gi;
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?retmode=text&retmax=10&db=Nucleotide&list_uids=$gi&dopt=xml");
			#printf "XML '%s'\n", $page;
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			my $pgi = $xml->{'Bioseq-set_seq-set'}->[0]->{'Seq-entry'}->[0]->{'Seq-entry_set'}->[0]->{'Bioseq-set'}->[0]->{'Bioseq-set_annot'}->[0]->{'Seq-annot'}->[0]->{'Seq-annot_data'}->[0]->{'Seq-annot_data_ftable'}->[0]->{'Seq-feat'}->[0]->{'Seq-feat_product'}->[0]->{'Seq-loc'}->[0]->{'Seq-loc_whole'}->[0]->{'Seq-id'}->[0]->{'Seq-id_gi'}->[0];
			printf "%s\n", $pgi;
			$sthUpdate->execute( $pgi, $id );
			#last;
		}
	}
	if (1 == 0) { # guys with no pgi - get nucl.seq
		my $sthGet = $ddb_global{dbh}->prepare(sprintf "SELECT id,gi FROM %s.%s WHERE gi != 0 AND pgi = 0 AND nucleotide_sequence IS NULL", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		my $sthUpdate = $ddb_global{dbh}->prepare(sprintf "UPDATE %s.%s SET nucleotide_sequence = ? WHERE id = ?", $RESULT->get_resultdb(),$RESULT->get_table_name() );
		$sthGet->execute();
		printf "Trying to update %d rows\n", $sthGet->rows();
		require LWP::Simple;
		require XML::Simple;
		while (my ($id,$gi) = $sthGet->fetchrow_array()) {
			#next if $gi == 662761;
			#next if $gi == 976373;
			printf "ID: %s GI: %s\n", $id, $gi;
			my $page = LWP::Simple::get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?retmode=text&retmax=10&db=Nucleotide&list_uids=$gi&dopt=xml");
			#printf "XML '%s'\n", $page;
			my $xml = XML::Simple::XMLin( $page, forcearray => 1 );
			my $nucl = $xml->{'Bioseq-set_seq-set'}->[0]->{'Seq-entry'}->[0]->{'Seq-entry_seq'}->[0]->{'Bioseq'}->[0]->{'Bioseq_inst'}->[0]->{'Seq-inst'}->[0]->{'Seq-inst_seq-data'}->[0]->{'Seq-data'}->[0]->{'Seq-data_iupacna'}->[0]->{'IUPACna'}->[0]; #->[0]->{'Seq-loc'}->[0]->{'Seq-loc_whole'}->[0]->{'Seq-id'}->[0]->{'Seq-id_gi'}->[0];
			#my $pgi = $xml->{'Bioseq-set_seq-set'}->[0]->{'Seq-entry'}->[0]->{'Seq-entry_set'}->[0]->{'Bioseq-set'}->[0]->{'Bioseq-set_annot'}->[0]->{'Seq-annot'}->[0]->{'Seq-annot_data'}->[0]->{'Seq-annot_data_ftable'}->[0]->{'Seq-feat'}->[0]->{'Seq-feat_product'}->[0]->{'Seq-loc'}->[0]->{'Seq-loc_whole'}->[0]->{'Seq-id'}->[0]->{'Seq-id_gi'}->[0];
			printf "Jucl ref %s val %s\n", ref($nucl),$nucl;
			$sthUpdate->execute( $nucl, $id );
			#last;
		}
	}
}
sub ddbResult_21 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $log;
	my $RE20 = DDB::RESULT->get_object( id => 20 );
	require DDB::PEPTIDE;
	my $data = $RE20->get_data();
	for my $row (@$data) {
		my %data;
		$data{p4_experiment_key} = $row->[0];
		$data{p5_experiment_key} = $row->[2];
		my $aryref1 = DDB::PEPTIDE->get_ids( experiment_key => $row->[0], prophet_probability_over => 0.9 );
		my $aryref2 = DDB::PEPTIDE->get_ids( experiment_key => $row->[2], prophet_probability_over => 0.9 );
		$data{p4_n_peptides} = $#$aryref1+1;
		$data{p5_n_peptides} = $#$aryref2+1;
		$RESULT->insertignore( %data );
		printf "%s\n",join "\t", @$row,$#$aryref1+1,$#$aryref2+1;
	}
	return $log;
}
sub ddbResult_23 {
	my(%param)=@_;
	my $RESULT = $param{result};
	my $log;
	my $RE20 = DDB::RESULT->get_object( id => 20 );
	require DDB::PEPTIDE;
	my $col = $RE20->get_data_column( column => 'brunn', uniq => 1 );
	printf "%d entries\n", $#$col+1;
	for my $brunn (@$col) {
		my %data;
		$data{brunn} = $brunn;
		my $p4 = $RE20->get_data_column( column => 'exp_p4_key', where => ["brunn = $brunn"] );
		my $p5 = $RE20->get_data_column( column => 'exp_p5_key', where => ["brunn = $brunn"] );
		$data{exp_p4_string} = join ",", @$p4;
		$data{exp_p5_string} = join ",", @$p5;
		my $aryref1 = DDB::PEPTIDE->get_ids( experiment_key_aryref => $p4, prophet_probability_over => 0.9 );
		my $aryref2 = DDB::PEPTIDE->get_ids( experiment_key_aryref => $p5, prophet_probability_over => 0.9 );
		my %p4;
		my %p5;
		for my $id (@$aryref1) {
			my $PEPTIDE = DDB::PEPTIDE->get_object( id => $id );
			$p4{ $PEPTIDE->get_peptide() } = 1;
		}
		for my $id (@$aryref2) {
			my $PEPTIDE = DDB::PEPTIDE->get_object( id => $id );
			$p5{ $PEPTIDE->get_peptide() } = 1;
		}
		my @keys4 = keys %p4;
		my @keys5 = keys %p5;
		$data{p4_n_peptides} = $#keys4+1;
		$data{p5_n_peptides} = $#keys5+1;
		$data{tot_p4_n_peptides} = $#$aryref1+1;
		$data{tot_p5_n_peptides} = $#$aryref2+1;
		printf "%s: %s\n",$brunn, join ", ", map{ my $s = sprintf "%s => %s", $_, $data{$_} }keys %data;
		$RESULT->insertignore( %data );
	}
	return $log;
}
sub ddbResult_35 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::PROGRAM::PIMW;
	my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM ddb.explorerProtein INNER JOIN ddb.protein ON protein_key = protein.id WHERE explorer_key = 33");
	for my $id (@$aryref) {
		my $pos = 1;
		my $buf = 1;
		my $buff = 0;
		my $fseq = $ddb_global{dbh}->selectrow_array("SELECT sequence FROM ddb.sequence WHERE id = $id");
		#printf "FULL (%d aa):\n%s\n",length($fseq), $fseq;
		for (my $i = 0; $i < length($fseq); $i++) {
			eval {
				my $current = substr($fseq,$i,1);
				if ($current eq 'K' || $current eq 'R' || $i == length($fseq)-1) {
					my $stop = $i+1;
					my $start = $buff;
					my $sseq = substr($fseq,$start,$stop-$start);
					#printf "%s %s %s\n", $start,$stop,$sseq;
					$buff = $stop;
					my $pi,my $mw;
					($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $sseq ) if $sseq;
					my %data;
					my $has = ($sseq =~ /C/) ? 'yes':'no';
					$data{sequence_key} = $id;
					$data{start} = $start+1;
					$data{stop} = $stop;
					$data{mw} = $mw;
					$data{pI} = $pi;
					$data{hasCystine} = $has;
					$data{sequence} = $sseq;
					$RESULT->insertignore( %data ) if $sseq;
				};
				printf "FAILED %s\n", (split /\n/, $@)[0] if $@;
			}
		}
		while (1==0) {
			my $posk = $ddb_global{dbh}->selectrow_array("SELECT LOCATE('K',sequence,$pos) from {nrseq_table} WHERE id = $id");
			my $posr = $ddb_global{dbh}->selectrow_array("SELECT LOCATE('R',sequence,$pos) from {nrseq_table} WHERE id = $id");
			$pos = ($posk > $posr) ? $posk : $posr;
			my $last = 1 unless $pos;
			$pos += 1; # length of match
			my $sseq;
			unless ($last) {
				$sseq = $ddb_global{dbh}->selectrow_array(sprintf "SELECT SUBSTRING(sequence,%d,%d) from {nrseq_table} WHERE id = %d",$buf,$pos-$buf,$id);
			} else {
				$sseq = $ddb_global{dbh}->selectrow_array("SELECT SUBSTRING(sequence,$buf) from {nrseq_table} WHERE id = $id");
			}
			my $to = $pos-1;
			$to = length($fseq) if $pos == 1;
			my $pi; my $mw;
			($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $sseq ) if $sseq;
			printf "%d %d %d (%d aa) pI: %s MW: %s\n%s\n", $id,$buf,$to,length($sseq),$pi,$mw,$sseq;
			my %data;
			my $has = ($sseq =~ /C/) ? 'yes':'no';
			$data{sequence_key} = $id;
			$data{start} = $buf;
			$data{stop} = $to;
			$data{mw} = $mw;
			$data{pI} = $pi;
			$data{hasCystine} = $has;
			$data{sequence} = $sseq;
			$RESULT->insertignore( %data ) if $sseq;
			$buf = $pos;
			last if $last;
		}
	}
}
sub ddbResult_36 {
	my(%param)=@_;
	my $RESULT = $param{result};
	$ddb_global{dbh}->do(sprintf "DROP TABLE IF EXISTS %s.%s", $RESULT->get_resultdb(),$RESULT->get_table_name() );
	my $statement = sprintf "CREATE TABLE %s.%s (id int primary key not null auto_increment, tag varchar(50) not null,with_cystine enum('yes','no') not null, mw_upper int not null, mw_lower int not null, pi_upper double not null, pi_lower double not null,pi_range double not null, n_peptide int not null,n_uniq_peptide int not null, n_sequence int not null, percent_sequence double not null,unique(tag,mw_upper,mw_lower,pi_upper,pi_lower,with_cystine))",$RESULT->get_resultdb(),$RESULT->get_table_name();
	$ddb_global{dbh}->do($statement);
	my $mw_upper = 4000;
	my $mw_lower = 800;
	my $n_tot = 139;
	for my $upper (qw( 4 4.5 5 5.5 6 6.5 7 7.5 8 10 )) {
		last;
		for my $lower (qw( 3.5 4 4.5 5 5.5 6 6.5 7 7.5 8 9.5 )) {
			last;
			my %data;
			next unless $upper > $lower;
			$data{mw_upper} = $mw_upper;
			$data{tag} = 'lm_range';
			$data{mw_lower} = $mw_lower;
			$data{pi_lower} = $lower;
			$data{pi_upper} = $upper;
			my ($npep,$nseq) = $ddb_global{dbh}->selectrow_array("SELECT COUNT(*),COUNT(DISTINCT sequence_key) FROM ddbResult.humanGenomeTrypticPeptides WHERE mw <= $mw_upper and mw >= $mw_lower and pi >= $lower and pi <= $upper");
			$data{n_peptide} = $npep;
			$data{n_sequence} = $nseq;
			$data{percent_sequence} = $nseq/$n_tot;
			$RESULT->insertignore(%data);
			printf "%s %s\n", $npep,$nseq;
			#last;
		}
		#last;
	}
	for my $c (qw( yes no )) {
		for my $code (qw("IPGrange")) { #,3.5,4.5 "IPGrange",4,5 "IPGrange",4.5,5.5 "IPGrange",5,6 "IPGrange",5.3,6.5 "IPGrange",5.5,6.7 "IPGrange",6.2,7.5 "IPGrange",3,5.6 "IPGrange",4,7 "IPGrange",6,9 "IPGrange",3,7 "IPGrange",7,11 "IPGrange",6,11 "IPGrange",3,10 "FFE-range",0,3.82580362058635 "FFE-range",3.82580362058635,3.87258164823225 "FFE-range",3.87258164823225,3.87611490103925 "FFE-range",3.87611490103925,3.91212463502705 "FFE-range",3.91212463502705,4.03591807600265 "FFE-range",4.03591807600265,4.1796662308341 "FFE-range",4.1796662308341,4.3148902630528 "FFE-range",4.3148902630528,4.3767680368603 "FFE-range",4.3767680368603,4.3947720770962 "FFE-range",4.3947720770962,4.4559908047435 "FFE-range",4.4559908047435,4.495445659298 "FFE-range",4.495445659298,4.48402443372165 "FFE-range",4.48402443372165,4.5238066724523 "FFE-range",4.5238066724523,4.55649394134605 "FFE-range",4.55649394134605,4.901706144492 "FFE-range",4.901706144492,4.9605440081972 "FFE-range",4.9605440081972,4.99114206809395 "FFE-range",4.99114206809395,5.3359076513431 "FFE-range",5.3359076513431,5.171154857461 "FFE-range",5.171154857461,5.6555022345649 "FFE-range",5.6555022345649,6.1364732047108 "FFE-range",6.1364732047108,5.89613985718835 "FFE-range",5.89613985718835,5.8801775776223 "FFE-range",5.8801775776223,5.95525767464085 "FFE-range",5.95525767464085,5.98164386669235 "FFE-range",5.98164386669235,6.04714197837515 "FFE-range",6.04714197837515,6.1534986866845 "FFE-range",6.1534986866845,6.18089668966675 "FFE-range",6.18089668966675,6.8862093390757 "FFE-range",6.8862093390757,7.39607048034665 "FFE-range",7.39607048034665,7.2975814764139 "FFE-range",7.2975814764139,8.1116964606376 "FFE-range",8.1116964606376,8.9097452523462 "FFE-range",8.9097452523462,12 "IPG3_8to4_5",0,3.4065935 "IPG3_8to4_5",3.4065935,3.4939755 "IPG3_8to4_5",3.4939755,3.5667775 "IPG3_8to4_5",3.5667775,3.6323495 "IPG3_8to4_5",3.6323495,3.690268 "IPG3_8to4_5",3.690268,3.7403795 "IPG3_8to4_5",3.7403795,3.799416 "IPG3_8to4_5",3.799416,3.8675885 "IPG3_8to4_5",3.8675885,3.9366155 "IPG3_8to4_5",3.9366155,4.006537 "IPG3_8to4_5",4.006537,4.0684045 "IPG3_8to4_5",4.0684045,4.121997 "IPG3_8to4_5",4.121997,4.180583 "IPG3_8to4_5",4.180583,4.2395715 "IPG3_8to4_5",4.2395715,4.2988855 "IPG3_8to4_5",4.2988855,4.3629855 "IPG3_8to4_5",4.3629855,4.4225765 "IPG3_8to4_5",4.4225765,4.5001935 "IPG3_8to4_5",4.5001935,4.577401 "IPG3_8to4_5",4.577401,4.6750935 "IPG3_8to4_5",4.6750935,4.796435 "IPG3_8to4_5",4.796435,4.8635225 "IPG3_8to4_5",4.8635225,4.942029 "IPG3_8to4_5",4.942029,10 "JM_Range",3.5,3.77083333333333 "JM_Range",3.77083333333333,3.89583333333333 "JM_Range",3.89583333333333,4 "JM_Range",4,4.02083333333333 "JM_Range",4.02083333333333,4.13541666666667 "JM_Range",4.13541666666667,4.1875 "JM_Range",4.1875,4.25 "JM_Range",4.25,4.35416666666667 "JM_Range",4.35416666666667,4.375 "JM_Range",4.375,4.5)) {
			my %data;
			my ($tag,$lower,$upper) = split /,/,$code;
			$tag =~ s/\"//g;
			#confess sprintf "%s %s %s %s\n", $tag,$lower,$upper,$code;
			$data{tag} = $tag;
			$data{mw_upper} = $mw_upper;
			$data{with_cystine} = $c;
			$data{mw_lower} = $mw_lower;
			$data{pi_lower} = $lower;
			$data{pi_upper} = $upper;
			$data{pi_range} = $upper-$lower;
			my ($npep,$nupep,$nseq) = $ddb_global{dbh}->selectrow_array(sprintf "SELECT COUNT(*),COUNT(DISTINCT sequence),COUNT(DISTINCT sequence_key) FROM ddbResult.tgfBpeptides WHERE mw <= $mw_upper and mw >= $mw_lower and pi >= $lower and pi <= $upper %s",($c eq 'yes') ? "AND hasCystine = 'yes'": '');
			$data{n_peptide} = $npep;
			$data{n_uniq_peptide} = $nupep;
			$data{n_sequence} = $nseq;
			$data{percent_sequence} = $nseq/$n_tot;
			$RESULT->insertignore(%data);
			printf "%s %s %s\n",$c, $npep,$nseq;
			#last;
		}
	}
	return '';
}
sub ddbResult_38 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::PEPTIDE;
	my $aryref = DDB::PEPTIDE->get_ids( experiment_key => 80, prophet_probability_over => 0.9 );
	$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
	$RESULT->querydo("CREATE TABLE #TABLE# (id int primary key not null auto_increment, experiment_key int not null,sequence varchar(255) not null, molecular_weight double, pi double, modified enum('yes','no') not null default 'no',has_pattern enum('yes','no') not null default 'no',UNIQUE(sequence))");
	printf "%d\n", $#$aryref+1;
	for my $id (@$aryref) {
		my $PEPTIDE = DDB::PEPTIDE->get_object( id => $id );
		my %data;
		$data{sequence} = $PEPTIDE->get_peptide();
		$data{experiment_key} = $PEPTIDE->get_experiment_key();
		$data{molecular_weight} = $PEPTIDE->get_molecular_weight();
		$data{pi} = $PEPTIDE->get_pi();
		$data{modified} = 'no';
		$data{has_pattern} = ($PEPTIDE->get_peptide() =~ /N.[ST]/) ? 'yes' : 'no';
		#printf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
		$RESULT->insertignore( %data );
		if ($data{has_pattern}) {
			my %datamod;
			my $peptide = $PEPTIDE->get_peptide();
			$peptide =~ s/N(.[ST])/D$1/g;
			$datamod{sequence} = $peptide;
			$datamod{experiment_key} = $PEPTIDE->get_experiment_key();
			require DDB::PROGRAM::PIMW;
			($datamod{pi}, $datamod{molecular_weight}) = DDB::PROGRAM::PIMW->calculate( sequence => $peptide );
			$datamod{modified} = 'yes';
			$datamod{has_pattern} = 'yes';
			$RESULT->insertignore( %datamod );
		}
		#last;
	}
}
sub ddbResult_48 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::PROGRAM::PIMW;
	if (1==0) {
		$RESULT->querydo("DELETE FROM #TABLE#");
	}
	if (1==1) {
		$ddb_global{dbh}->do("DROP TABLE IF EXISTS test.seq");
		$ddb_global{dbh}->do("CREATE TEMPORARY TABLE test.seq (sequence VARCHAR(2050) NOT NULL) ENGINE='HEAP'");
		$ddb_global{dbh}->do("INSERT test.seq (sequence) SELECT sequence FROM ddb.sequence INNER JOIN ddb.protein ON sequence_key = sequence.id WHERE experiment_key = 1389");
	}
	if (1==1) {
		my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM ddb.protein WHERE experiment_key = 1389");
		#my $aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT sequence_key FROM ddb.protein WHERE experiment_key = 1389 AND sequence_key = 177891"); #short seq
		for my $id (@$aryref) {
			my $fseq = $ddb_global{dbh}->selectrow_array("SELECT sequence FROM ddb.sequence WHERE id = $id");
			i: for (my $i = 0; $i < length($fseq); $i++) {
				j: for (my $j = $i+1; $j < length($fseq); $j++) {
					my $before = ($i > 0 ) ? substr($fseq,$i-1,1) : '';
					my $sseq = substr($fseq,$i,$j-$i+1);
					my $last = substr($sseq,length($sseq)-1,1);
					my ($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $sseq );
					next j if $mw < 800;
					last j if $mw > 5000;
					my %data;
					my $has = ($sseq =~ /C/) ? 'yes':'no';
					$data{sequence_key} = $id;
					$data{start} = $i+1;
					$data{stop} = $j+1;
					$data{mw} = $mw;
					$data{pI} = $pi;
					$data{hasCystine} = $has;
					$data{nterm} = 'yes' if $i == 0;
					$data{cterm} = 'yes' if $j == length($fseq)-1;
					if (($data{nterm} || $before eq 'K' || $before eq 'R') && ($data{cterm} || $last eq 'K' || $before eq 'R')) {
						$data{tryptic} = 'yes';
					} else {
						$data{tryptic} = 'no';
					}
					$data{sequence} = $sseq;
					$data{n_in_genome} = $ddb_global{dbh}->selectrow_array("SELECT COUNT(*) FROM test.seq WHERE sequence LIKE '%$sseq%'");
					$RESULT->insertignore( %data ) if $sseq;
				}
			}
		}
	}
}
#sub tmpddbResult_54 {
	#my $sthGlobal = $ddb_global{dbh}->prepare(sprintf "SELECT scan_key,precursorMz,peptide_key,peak1_mz,peak2_mz FROM %s.%s",$RES50->get_resultdb(),$RES50->get_table_name());
	#$sthGlobal->execute();
	#while (my $hash = $sthGlobal->fetchrow_hashref()) {
	#}
	#my $have = $RESULT->get_data_column( column => 'id', where => { scan_key => $hash->{scan_key} } );
	#next unless $#$have < 0;
	#my $PEP = DDB::PEPTIDE->get_object( id => $hash->{peptide_key} );
	#for my $col (qw( peak1_mz peak2_mz )) {
sub ddbResult_50 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::MZXML::SCAN;
	require DDB::MZXML::PEAK;
	require DDB::PEPTIDE;
	require DDB::PEPTIDE::PROPHET;
	my $RES52 = DDB::RESULT->get_object( id => 52 );
	my $sthDens = $ddb_global{dbh}->prepare(sprintf "SELECT scan_key FROM ddbResult.peakDensity WHERE ABS(precursorMz-?) < 0.5 AND ABS(mz-?) < 0.5");
	my $sthPep = $ddb_global{dbh}->prepare("SELECT sequence FROM test.hum WHERE scan_key = ?");
	$ddb_global{dbh}->do("CREATE TEMPORARY TABLE test.hum SELECT scan_key,sequence,peptide_key,MAX(probability) AS max_prob,MIN(probability) AS min_prob,COUNT(*) AS count FROM $DDB::PEPTIDE::PROPHET::obj_table pp INNER JOIN ddb.peptide ON peptide.id = peptide_key WHERE scan_key != 0 AND probability >= 0.7 GROUP BY scan_key,sequence");
	$ddb_global{dbh}->do("ALTER TABLE test.hum ADD UNIQUE(scan_key)");
	#my $scan_aryref = [529172];
	#my $scan_aryref = $ddb_global{dbh}->selectcol_arrayref("SELECT DISTINCT scan_key FROM $DDB::PEPTIDE::PROPHET::obj_table pp INNER JOIN ddb.peptide on peptide_key = peptide.id WHERE scan_key != 0 AND probability < 0.9 ORDER BY probability DESC");
	my $RES57 = DDB::RESULT->get_object( id => 57 );
	my $scan_aryref = $ddb_global{dbh}->selectcol_arrayref(sprintf "SELECT DISTINCT scan_key FROM backups.full_MRM_20060722 t INNER JOIN %s.%s v ON t.sequence_key = v.sequence_key",$RES57->get_resultdb(),$RES57->get_table_name());
	printf "%d spectra to consider\n", $#$scan_aryref+1;
	for my $scan_id (@$scan_aryref) {
		my $c = $RESULT->get_data_cell( column => 'id', where => { scan_key => $scan_id }, no_data_ok => 1 );
		next if $c;
		my %data;
		my $SCAN = DDB::MZXML::SCAN->get_object( id => $scan_id );
		$data{scan_key} = $SCAN->get_id();
		$data{retentionTime} = $SCAN->get_retentionTime();
		$data{basePeakIntensity} = $SCAN->get_basePeakIntensity();
		$data{totalIonCurrent} = $SCAN->get_totIonCurrent();
		$data{precursorMz} = $SCAN->get_precursorMz();
		$data{retentionTime} =~ s/[a-zA-Z]//g;
		my $peptide_aryref = DDB::PEPTIDE->get_ids( scan_key => $SCAN->get_id() );
		my $MPEP;
		for my $peptide_id (@$peptide_aryref) {
			my $PEPTIDE = DDB::PEPTIDE->get_object( id => $peptide_id );
			$MPEP = $PEPTIDE unless $MPEP;
			$MPEP = $PEPTIDE if $PEPTIDE->get_probability() > $MPEP->get_probability();
		}
		my $protein_aryref = $MPEP->get_protein_ids();
		$data{protein_key} = $protein_aryref->[0];
		$data{peptide_key} = $MPEP->get_id();
		$data{peptide_probability} = $MPEP->get_probability();
		$data{peptide_sequence} = $MPEP->get_peptide();
		my $ion_type = { y => 'blue', b => 'red' };
		my $charge_state = [ 1, 2 ];
		my @peaks = DDB::MZXML::PEAK->get_peaks( scan => $SCAN );
		my @tpeaks = DDB::MZXML::PEAK->get_theoretical_peaks( peptide => $MPEP, charge_state => $charge_state, ion_type => $ion_type, peaks => \@peaks, scan => $SCAN );
		my $count = 0;
		for my $PEAK (sort{ $b->get_intensity() <=> $a->get_intensity() }@peaks) {
			next unless $PEAK->get_comment() eq 'yes'; # dangerous. might change
			next unless $PEAK->get_type();
			next unless $PEAK->get_mz() >= $SCAN->get_precursorMz()*1.1;
			next if $PEAK->get_intensity()*25 < $SCAN->get_highest_peak();
			last if $count++ > 3;
			$sthDens->execute( $SCAN->get_precursorMz(),$PEAK->get_mz() );
			while (my $scan_key = $sthDens->fetchrow_array()) {
				$sthPep->execute( $scan_key );
				if ($sthPep->rows() == 0) {
					$data{'peak'.$count.'_unassigned'}++;
				} elsif ($sthPep->rows() > 1) {
					confess "Cannot happend\n";
				} else {
					my $seq = $sthPep->fetchrow_array();
					#printf "%s %s\n", $seq,$MPEP->get_peptide();
					if ($seq eq $MPEP->get_peptide()) {
						$data{'peak'.$count.'_correct'}++;
					} else {
						$data{'peak'.$count.'_incorrect'}++;
					}
				}
			}
			$data{'peak'.$count.'_name'} = sprintf "%s%02d_%d+",$PEAK->get_type(),$PEAK->get_n(),$PEAK->get_charge();
			$data{'peak'.$count.'_mz'} = $PEAK->get_mz();
			$data{'peak'.$count.'_int'} = $PEAK->get_intensity();
		}
		#printf "%s\n", join "\n", map{ sprintf "%s => %s", $_, $data{$_} }keys %data;
		$RESULT->insertignore( %data );
	}
	$RESULT->querydo("UPDATE #TABLE# MRM INNER JOIN ddb.peptide ON peptide_key = peptide.id SET MRM.pI = peptide.pI WHERE MRM.pI = 0");
	$RESULT->querydo("UPDATE #TABLE# MRM INNER JOIN ddb.peptide ON peptide_key = peptide.id SET MRM.mw = peptide.molecular_weight WHERE MRM.mw = 0");
	$RESULT->querydo("UPDATE #TABLE# MRM INNER JOIN ddb.protein ON protein_key = protein.id SET MRM.sequence_key = protein.sequence_key WHERE MRM.sequence_key = 0");
	$RESULT->querydo("UPDATE #TABLE# MRM INNER JOIN #TABLE48# pyo ON MRM.sequence_key = pyo.sequence_key AND MRM.peptide_sequence = pyo.sequence SET MRM.n_in_genome = pyo.n_in_genome, MRM.tryptic = pyo.tryptic WHERE MRM.n_in_genome = 0 AND MRM.tryptic = ''");
}
sub ddbResult_51 {
	my(%param)=@_;
	require DDB::PROGRAM::PIMW;
	my $RESULT = $param{result};
	my $RES50 = DDB::RESULT->get_object( id => 50 );
	my $log = '';
	my $sthGlobal = $ddb_global{dbh}->prepare(sprintf "SELECT sequence_key,COUNT(*) AS c FROM %s.%s WHERE tryptic = 'yes' AND peptide_probability >= 0.9 AND n_in_genome = 1 AND data_set = 'A' GROUP BY sequence_key ORDER BY c",$RES50->get_resultdb(),$RES50->get_table_name());
	$sthGlobal->execute();
	$log .= sprintf "Found %d proteins\n", $sthGlobal->rows();
	while (my($seq,$seq_scan_count) = $sthGlobal->fetchrow_array()) {
		$log .= sprintf "SeqKey %s n_scans: %s\n", $seq,$seq_scan_count;
		my $sthSeq = $ddb_global{dbh}->prepare(sprintf "SELECT peptide_sequence,charge_state,M_oxidized,COUNT(*) AS c,MAX(retentionTime) AS maxtime,MIN(retentionTime) AS mintime,AVG(retentionTime) AS avgtime,stddev_samp(retentionTime) AS stddev,GROUP_CONCAT(DISTINCT round(retentionTime/100,0)*100) AS retex,MAX(precursorMz) AS maxpre, MIN(precursorMz) AS minpre,AVG(precursorMz) AS avgpre,stddev_samp(precursorMz) AS sdpre,GROUP_CONCAT(DISTINCT ROUND(precursorMz/10,0)*10) AS preex FROM %s.%s WHERE sequence_key = ? AND n_in_genome = 1 AND peptide_probability >= 0.9 AND tryptic = 'yes' AND data_set = 'A' GROUP BY peptide_sequence,charge_state,M_oxidized ORDER BY c DESC",$RES50->get_resultdb(),$RES50->get_table_name());
		$sthSeq->execute($seq);
		$log .= sprintf "%s peptides\n", $sthSeq->rows();
		my $npep = 0;
		my $n = 0;
		my %pep_buff;
		while (my ($pepseq,$charge_state,$m_oxi,$pep_scan_count,$maxtime,$mintime,$avgtime,$sdtime,$retex,$maxpre,$minpre,$avgpre,$sdpre,$preex) = $sthSeq->fetchrow_array()) {
			if (!$pep_buff{$pepseq} && $npep < 2) {
				$pep_buff{$pepseq} = ++$npep;
			}
			next unless $pep_buff{$pepseq};
			$n = $pep_buff{$pepseq};
			$log .= sprintf "Seq: %s charge: %d ozi: %s n_scans: %s\n", $pepseq,$charge_state,$m_oxi,$pep_scan_count;
			my %data = ( sequence_key => $seq, seq_scan_count => $seq_scan_count, peptide_sequence => $pepseq, pep_scan_count => $pep_scan_count, maxtime => $maxtime, mintime => $mintime, avgtime => $avgtime,sdtime => $sdtime || -1,ret => $retex, maxpre => $maxpre, minpre => $minpre, avgpre => $avgpre, sdpre => $sdpre || - 1, pre => $preex, n => $n, charge_state => $charge_state, M_oxidized => $m_oxi );
			for my $peakn (qw( 1 2 )) {
				my $sthPeak = $ddb_global{dbh}->prepare(sprintf "SELECT peak%d_name,COUNT(*) AS peak%d_scan_count,AVG(peak%d_mz) AS mz%d,MAX(peak%d_mz)-MIN(peak%d_mz) AS mzrange%d,AVG(peak%d_int) AS intensity%d,scan_key AS example%s_scan_key,peak%d_correct/(peak%d_correct+peak%d_incorrect) AS fraction%d FROM %s.%s WHERE sequence_key = ? AND peptide_sequence = ? AND peptide_probability >= 0.9 AND n_in_genome = 1 AND tryptic = 'yes' AND data_set = 'A' AND peak%d_name != '' AND charge_state = %d AND M_oxidized = '%s' GROUP BY peak%d_name ORDER BY fraction%d,peak%d_scan_count DESC",$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$peakn,$RES50->get_resultdb(),$RES50->get_table_name(),$peakn,$charge_state,$m_oxi,$peakn,$peakn,$peakn);
				$sthPeak->execute( $seq,$pepseq );
				while (my $hash = $sthPeak->fetchrow_hashref()) {
					map{ $data{$_} = $hash->{$_} || 0 }keys %$hash;
					last;
				}
				if ($data{'peak'.$peakn.'_name'}) {
					my $seq;
					my $add = 0;
					if ($data{'peak'.$peakn.'_name'} =~ /^y(\d+)_(\d+)+/) {
						$seq = substr($data{peptide_sequence},length($data{peptide_sequence})-$1,$1);
					} elsif ($data{'peak'.$peakn.'_name'} =~ /^b(\d+)_(\d+)+/) {
						$seq = substr($data{peptide_sequence},0,$1);
						$add = -18.01528;
					} else {
						confess "Unrecognized peak_name\n";
					}
					warn sprintf "%s %s %s",$seq,$data{peptide_sequence},$data{'peak'.$peakn.'_name'};
					my($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $seq ) if $seq;
					$data{'tmz'.$peakn} = ($mw+$add+$2*1.0079)/$2;
				}
			}
			#$log .= sprintf "%s\n",join ", ", map{ sprintf "%s => %s", $_, $data{$_} }sort{ $a cmp $b }keys %data;
			my($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $data{peptide_sequence}) if $data{peptide_sequence};
			my $oxi = ($data{M_oxidized}eq'yes')?16/$data{charge_state}:0;
			$data{theoretical_mw} = ($mw+$data{charge_state}*1.0079)/$data{charge_state}+$oxi;
			$RESULT->insert( %data );
		}
	}
	return $log;
}
sub ddbResult_52 {
	my(%param)=@_;
	my $RESULT = $param{result};
	require DDB::MZXML::SCAN;
	require DDB::MZXML::PEAK;
	my $aryref = DDB::MZXML::SCAN->get_ids( sLevel => 2 );
	#my $aryref = [639274];
	for my $id (@$aryref) {
		my $SCAN = DDB::MZXML::SCAN->get_object( id => $id );
		my @peaks = DDB::MZXML::PEAK->get_peaks( scan => $SCAN );
		#printf "%s %d %s %s\n", $SCAN->get_id(),$#peaks+1,$SCAN->get_highest_peak(),$SCAN->get_precursorMz();
		my $count = 0;
		my $ret = $SCAN->get_retentionTime();
		$ret =~ s/[A-Z]//g;
		for my $PEAK (@peaks) {
			next if $PEAK->get_mz() < $SCAN->get_precursorMz()*1.1;
			next if $PEAK->get_intensity()*25 < $SCAN->get_highest_peak();
			my %data = ( scan_key => $SCAN->get_id(), precursorMz => $SCAN->get_precursorMz(), highest_peak => $SCAN->get_highest_peak(), retention_time => $ret, mz => $PEAK->get_mz(), intensity => $PEAK->get_intensity() );
			$RESULT->insertignore( %data );
			#printf "%s %s %s %s\n", $PEAK->get_mz() , $SCAN->get_precursorMz(),$PEAK->get_intensity(), $SCAN->get_highest_peak();
			#$count++;
		}
		#printf "$count\n";
	}
}
sub ddbResult_58 {
	my(%param)=@_;
	my $RESULT = $param{result};
	if (1==0) {
		$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
		$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key,grp varchar(15) not null, experiment_key int not null,plot_order int not null, n_proteins int not null,protein_key int not null,peptide varchar(255) not null, molecular_weight double not null, nxst_motif enum('yes','no') not null default 'no',pI double not null, d_pI double not null,UNIQUE(experiment_key,peptide))");
	}
	require DDB::PEPTIDE;
	if (1==0) {
		require DDB::PEPTIDE::PROPHET;
		my $pep_aryref = $ddb_global{dbh}->selectcol_arrayref(sprintf "SELECT DISTINCT peptide.id FROM peptide INNER JOIN %s pp ON peptide.id = peptide_key WHERE probability >= 0.9 AND experiment_key >= 1391 AND experiment_key <= 1444",$DDB::PEPTIDE::PROPHET::obj_table);
		printf "%d\n", $#$pep_aryref+1;
		for my $id (@$pep_aryref) {
			my $PEP = DDB::PEPTIDE->get_object( id => $id );
			my $prot_ary = $PEP->get_protein_ids();
			my %data;
			$data{experiment_key} = $PEP->get_experiment_key();
			$data{peptide} = $PEP->get_peptide();
			$data{pI} = $PEP->get_pi();
			$data{molecular_weight} = $PEP->get_molecular_weight();
			$data{nxst_motif} = ($PEP->get_peptide() =~ /N.[ST]/) ? 'yes' : 'no';
			$data{n_proteins} = $#$prot_ary+1;
			$data{protein_key} = $prot_ary->[0] || -1;
			$RESULT->insertignore( %data );
		}
	}
	if (1==1) {
		$RESULT->querydo("UPDATE #TABLE# SET d_pI = pI WHERE nxst_motif = 'no'");
		my $stuff = $RESULT->get_data( columns => ['id','peptide','pI'], where => { nxst_motif => 'yes' } );
		require DDB::PROGRAM::PIMW;
		for my $row (@$stuff) {
			#printf "%s %s\n", $row->[0],$row->[1];
			my $seq = $row->[1];
			$seq =~ s/N(.[ST])/D$1/g;
			my($pi,$mw) = DDB::PROGRAM::PIMW->calculate( sequence => $seq );
			$RESULT->update( values => { d_pI => $pi }, where => { id => $row->[0] } );
		}
	}
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 1 WHERE experiment_key = 1396");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 2 WHERE experiment_key = 1397");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 3 WHERE experiment_key = 1444");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 4 WHERE experiment_key = 1395");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 5 WHERE experiment_key = 1394");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 6 WHERE experiment_key = 1393");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 7 WHERE experiment_key = 1391");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 8 WHERE experiment_key = 1431");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 9 WHERE experiment_key = 1432");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 10 WHERE experiment_key = 1433");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 11 WHERE experiment_key = 1434");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 12 WHERE experiment_key = 1435");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 13 WHERE experiment_key = 1436");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 14 WHERE experiment_key = 1438");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 15 WHERE experiment_key = 1437");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 16 WHERE experiment_key = 1440");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 17 WHERE experiment_key = 1439");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 18 WHERE experiment_key = 1442");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 19 WHERE experiment_key = 1441");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 20 WHERE experiment_key = 1426");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 21 WHERE experiment_key = 1427");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 22 WHERE experiment_key = 1428");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 23 WHERE experiment_key = 1429");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 24 WHERE experiment_key = 1430");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 1 WHERE experiment_key = 1412");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 2 WHERE experiment_key = 1413");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 3 WHERE experiment_key = 1414");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 4 WHERE experiment_key = 1415");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 5 WHERE experiment_key = 1416");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 6 WHERE experiment_key = 1417");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 7 WHERE experiment_key = 1418");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 8 WHERE experiment_key = 1419");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 9 WHERE experiment_key = 1420");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 10 WHERE experiment_key = 1421");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 11 WHERE experiment_key = 1422");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 12 WHERE experiment_key = 1423");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 13 WHERE experiment_key = 1400");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 14 WHERE experiment_key = 1401");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 15 WHERE experiment_key = 1402");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 16 WHERE experiment_key = 1403");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 17 WHERE experiment_key = 1404");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 18 WHERE experiment_key = 1405");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 19 WHERE experiment_key = 1406");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 20 WHERE experiment_key = 1407");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 21 WHERE experiment_key = 1408");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 22 WHERE experiment_key = 1409");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 23 WHERE experiment_key = 1410");
	$RESULT->querydo("UPDATE #TABLE# SET plot_order = 24 WHERE experiment_key = 1411");
}
sub ddbResult_82 {
	my(%param)=@_;
	my $RESULT = $param{result};
	$RESULT->querydo("DROP TABLE IF EXISTS #TABLE#");
	$RESULT->querydo("CREATE TABLE #TABLE# (id int not null auto_increment primary key, sequence_key int not null,project_nr int not null,unique(sequence_key),experiment_nr int not null)");
	my $count = 0;
	my $pcount = 0;
	for my $table (qw( 100_protein 103_protein 104_protein 108_protein )) {
		my $aryref = $RESULT->querycol(sprintf "SELECT DISTINCT experiment_key FROM %s.$table",$ddb_global{xplordb});
		$pcount++;
		for my $expkey (@$aryref) {
			$count++;
			$RESULT->querydo(sprintf "INSERT IGNORE #TABLE# (sequence_key,experiment_nr,project_nr) SELECT sequence_key,$count,$pcount FROM %s.$table WHERE experiment_key = $expkey AND prophet_probability >= 0.9",$ddb_global{xplordb});
		}
	}
}
sub GetBoundary {
	my $sth = shift;
	my @boundary;
	my $bufstop;
	while (my $hash = $sth->fetchrow_hashref()) {
		#printf "%s %s %s\n", $hash->{start},$hash->{stop},$hash->{domain_nr};
		if ($bufstop) {
			if (abs($hash->{start}-$bufstop)) {
				my $boundary = sprintf "%d", ($bufstop+1+$hash->{start})/2;
				#printf "Boundary: %s\n",$boundary;
				push @boundary, $boundary;
			}
		}
		$bufstop = $hash->{stop};
	}
	return @boundary;
}
1;
